//! Main chat view

use std::sync::Arc;

use gpui::*;
use gpui::prelude::*;
use gpui::prelude::*;

use crate::app::state::AppState;
use crate::claude::message::{ClaudeEvent, ClaudeMessage, MessageRole};
use crate::storage::models::{Conversation, Message};
use crate::ui::pct;

use crate::ui::chat::input::{ChatInput, ChatInputEvent};
use crate::ui::chat::message::{MessageView, MessageViewEvent};

use super::suggestions::{ContextualSuggestion, QuickReplySuggestion};
use super::types::*;

impl EventEmitter<ChatViewEvent> for ChatView {}

/// Chat view containing messages and input
pub struct ChatView {
    pub(crate) app_state: Arc<AppState>,
    /// Message entities (stateful, collapsible)
    pub(crate) message_views: Vec<Entity<MessageView>>,
    /// Raw messages for persistence
    pub(crate) messages: Vec<ClaudeMessage>,
    pub(crate) input: Entity<ChatInput>,
    pub(crate) is_streaming: bool,
    pub(crate) current_assistant_message: Option<String>,
    /// Streaming message view (temporary during streaming)
    pub(crate) streaming_message_view: Option<Entity<MessageView>>,
    /// Current conversation ID (if saved)
    pub(crate) current_conversation_id: Option<String>,
    /// Whether to show the stats bar
    pub(crate) show_stats: bool,
    /// Search query
    pub(crate) search_query: String,
    /// Whether search panel is visible
    pub(crate) show_search: bool,
    /// Current search results
    pub(crate) search_results: Vec<ConversationSearchResult>,
    /// Currently highlighted result index
    pub(crate) current_search_result: usize,
    /// Whether search is case-sensitive
    pub(crate) search_case_sensitive: bool,
    /// Whether search uses regex
    pub(crate) search_regex: bool,
    /// Role filter for search (which roles to search in)
    pub(crate) search_role_filter: MessageFilter,
    /// Whether user has scrolled away from bottom
    pub(crate) show_scroll_to_bottom: bool,
    /// Number of unread messages since scrolling away
    pub(crate) unread_count: usize,
    /// Current message filter
    pub(crate) message_filter: MessageFilter,
    /// Whether to show timestamps on messages
    pub(crate) show_timestamps: bool,
    /// Whether to show compact mode (less padding)
    pub(crate) compact_mode: bool,
    /// Whether to show time separators between message groups
    pub(crate) show_time_separators: bool,
    /// Conversation title (user-editable)
    pub(crate) conversation_title: Option<String>,
    /// Whether title is being edited
    pub(crate) editing_title: bool,
    /// Title edit buffer (temporary storage during editing)
    pub(crate) title_edit_buffer: String,
    /// Focus handle for title editing
    pub(crate) title_focus: FocusHandle,
    /// Whether to auto-scroll to bottom on new messages
    pub(crate) auto_scroll: bool,
    /// Currently selected message index for keyboard navigation
    pub(crate) selected_message_index: Option<usize>,
    /// Whether to show only bookmarked messages
    pub(crate) show_bookmarked_only: bool,
    /// Whether to wrap long lines in code blocks
    pub(crate) word_wrap: bool,
    /// Whether to show line numbers in code blocks
    pub(crate) show_line_numbers: bool,
    /// Session info from Claude CLI (commands, tools, etc.)
    pub(crate) session_info: Option<crate::claude::message::SessionInfo>,
    /// Session usage stats
    pub(crate) session_cost: f64,
    pub(crate) session_input_tokens: u64,
    pub(crate) session_output_tokens: u64,
    /// Active tasks/subagents
    pub(crate) active_tasks: Vec<ActiveTask>,
    /// Connection status
    pub(crate) connection_status: ConnectionStatus,
    /// Current notifications (toast-style)
    pub(crate) notifications: Vec<Notification>,
    /// Whether to show keyboard shortcuts help panel
    pub(crate) show_shortcuts_help: bool,
    /// Streaming progress animation frame (for smooth animation)
    pub(crate) streaming_dots: usize,
    /// Whether to show command palette
    pub(crate) show_command_palette: bool,
    /// Command palette search query
    pub(crate) palette_query: String,
    /// Selected index in command palette
    pub(crate) palette_selected_index: usize,
    /// Recently used commands (most recent first, max 10)
    pub(crate) recent_commands: Vec<String>,
    /// Last response time in milliseconds (for performance tracking)
    pub(crate) last_response_time_ms: Option<u64>,
    /// Response start time for measuring response duration
    pub(crate) response_start_time: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to show model switcher dropdown
    show_model_switcher: bool,
    /// Saved draft text (auto-saved input)
    draft_text: Option<String>,
    /// Time when draft was last saved
    pub(crate) draft_saved_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Context capacity in tokens (from Claude CLI)
    pub(crate) context_capacity: u64,
    /// Context used in tokens (estimated)
    pub(crate) context_used: u64,
    /// Available models for switching
    pub(crate) available_models: Vec<ModelInfo>,
    /// Contextual suggestions based on current state
    pub(crate) contextual_suggestions: Vec<ContextualSuggestion>,
    /// Whether to show suggestions bar
    pub(crate) show_suggestions: bool,
    /// Whether to show floating action button menu
    pub(crate) show_fab_menu: bool,
    /// Recent sessions for quick resume
    pub(crate) recent_sessions: Vec<RecentSession>,
    /// Whether to show session history panel
    pub(crate) show_session_history: bool,
    /// Last error message (for retry functionality)
    pub(crate) last_error: Option<ErrorInfo>,
    /// Pending permissions requests
    pub(crate) pending_permissions: Vec<PermissionRequest>,
    /// Whether to show permissions panel
    show_permissions_panel: bool,
    /// Whether to show MCP servers panel
    pub(crate) show_mcp_panel: bool,
    /// Whether to show active tasks panel
    pub(crate) show_tasks_panel: bool,
    /// Git information for current project
    pub(crate) git_info: Option<GitInfo>,
    /// Whether to show git panel
    pub(crate) show_git_panel: bool,
    /// File picker state
    pub(crate) file_picker_visible: bool,
    /// File picker query
    pub(crate) file_picker_query: String,
    /// File picker results
    pub(crate) file_picker_results: Vec<FilePickerItem>,
    /// Bookmarked message indices
    pub(crate) bookmarked_messages: std::collections::HashSet<usize>,
    /// Show only bookmarked messages
    pub(crate) show_bookmarks_only: bool,
    /// Multiline input mode
    pub(crate) multiline_input: bool,
    /// Input height in lines (for multiline mode)
    pub(crate) input_height_lines: u32,
    /// Show detailed session panel
    pub(crate) show_session_details: bool,
    /// Streaming tokens count (for speed calculation)
    pub(crate) streaming_token_count: usize,
    /// Last streaming speed (tokens per second)
    pub(crate) last_streaming_speed: f64,
    /// Peak streaming speed (tokens per second)
    pub(crate) peak_streaming_speed: f64,
    /// Total API requests made this session
    pub(crate) total_api_requests: u32,
    /// Show thinking/reasoning content
    pub(crate) show_thinking: bool,
    /// Current thinking content being streamed
    pub(crate) current_thinking: Option<String>,
    /// Currently executing tool name (for display)
    pub(crate) current_tool_name: Option<String>,
    /// Expanded MCP servers in panel (by name)
    pub(crate) expanded_mcp_servers: std::collections::HashSet<String>,
    /// Cached MCP server tools (server name -> tool names)
    pub(crate) mcp_server_tools: std::collections::HashMap<String, Vec<String>>,
    /// Whether to show commands panel (slash commands + skills)
    pub(crate) show_commands_panel: bool,
    /// Commands panel search filter
    pub(crate) commands_filter: String,
    /// Selected command category filter
    pub(crate) commands_category: CommandCategory,
    /// Whether to show prompt templates panel
    pub(crate) show_templates_panel: bool,
    /// Saved prompt templates
    pub(crate) prompt_templates: Vec<PromptTemplate>,
    /// Templates panel search filter
    pub(crate) templates_filter: String,
    /// Whether to show context panel (files, tools, etc.)
    pub(crate) show_context_panel: bool,
    /// Files mentioned/attached in this session
    pub(crate) context_files: Vec<ContextFile>,
    /// Whether to show export panel
    pub(crate) show_export_panel: bool,
    /// Selected export format
    pub(crate) export_format: ExportFormat,
    /// Whether to include metadata in export
    pub(crate) export_include_metadata: bool,
    /// Whether to include tool calls in export
    pub(crate) export_include_tools: bool,
    /// Whether to include thinking in export
    pub(crate) export_include_thinking: bool,
    /// Pinned message indices
    pub(crate) pinned_messages: std::collections::HashSet<usize>,
    /// Edit history stack (for undo)
    edit_history: Vec<EditHistoryEntry>,
    /// Current position in edit history
    edit_history_position: usize,
    /// Message reactions (message index -> list of reactions)
    message_reactions: std::collections::HashMap<usize, Vec<MessageReaction>>,
    /// Session notes
    pub(crate) session_notes: String,
    /// Whether to show notes panel
    pub(crate) show_notes_panel: bool,
    /// Quick action being shown (message index, None if hidden)
    quick_action_message: Option<usize>,
    /// Context menu state (message index, position)
    pub(crate) context_menu: Option<ContextMenuState>,
    /// Favorite prompts (quick access)
    pub(crate) favorite_prompts: Vec<FavoritePrompt>,
    /// Whether to show favorites panel
    pub(crate) show_favorites_panel: bool,
    /// Input focus mode (distraction-free)
    pub(crate) focus_mode: bool,
    /// Conversation tags
    pub(crate) conversation_tags: Vec<String>,
    /// Whether to show tags editor
    pub(crate) show_tags_editor: bool,
    /// Available quick reactions
    quick_reactions: Vec<&'static str>,
    /// Whether to show pinned messages panel
    pub(crate) show_pinned_panel: bool,
    /// Whether to show quick settings panel
    pub(crate) show_quick_settings: bool,
    /// Whether to show statistics panel
    pub(crate) show_stats_panel: bool,
    /// Input history for navigating previous inputs
    pub(crate) input_history: Vec<String>,
    /// Current position in input history (-1 means current input)
    pub(crate) input_history_position: i32,
    /// Temporary storage for current input when navigating history
    pub(crate) input_history_temp: String,
    /// Maximum input history size
    pub(crate) input_history_max: usize,
    /// Show input hints/suggestions
    pub(crate) show_input_hints: bool,
    /// Recently accessed files for quick access
    pub(crate) recent_files: Vec<RecentFile>,
    /// Whether to show recent files panel
    pub(crate) show_recent_files_panel: bool,
    /// Maximum recent files to track
    pub(crate) max_recent_files: usize,
    /// Highlighted message index (for search jump animation, with timestamp)
    pub(crate) highlighted_message: Option<(usize, std::time::Instant)>,
    /// Whether to show message preview on hover
    show_message_preview: bool,
    /// Quick navigation history (for back/forward navigation)
    pub(crate) navigation_history: Vec<usize>,
    /// Current position in navigation history
    pub(crate) navigation_history_position: usize,
    /// Whether file is being dragged over the view
    pub(crate) file_drag_active: bool,
    /// Number of files being dragged
    pub(crate) drag_file_count: usize,
    /// Session health score (0.0 to 1.0)
    pub(crate) session_health: f32,
    /// Last health check time
    pub(crate) last_health_check: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to show onboarding tips
    show_onboarding_tips: bool,
    /// Dismissed tips (by ID)
    dismissed_tips: std::collections::HashSet<&'static str>,
    /// Quick reply suggestions based on context
    pub(crate) quick_reply_suggestions: Vec<QuickReplySuggestion>,
    /// Whether to show typing indicators
    show_typing_indicator: bool,
    /// Connection retry count
    pub(crate) connection_retry_count: u32,
    /// Last successful response time (for latency tracking)
    pub(crate) last_response_latency_ms: Option<u64>,
    /// Average response latency (rolling average)
    pub(crate) avg_response_latency_ms: f64,
    /// Whether extended thinking mode is enabled
    pub(crate) think_mode_enabled: bool,
}


impl ChatView {
    pub fn new(app_state: Arc<AppState>, cx: &mut Context<Self>) -> Self {
        // Load draft from settings if available
        let saved_draft = app_state.settings.read(cx).draft_text.clone();

        let input = cx.new(|cx| {
            let mut input = ChatInput::new(app_state.clone(), cx);
            // Set default slash commands (these are common Claude CLI commands)
            input.set_available_commands(vec![
                // Help & Info
                "help".to_string(),
                "status".to_string(),
                "usage".to_string(),
                "cost".to_string(),
                // Context management
                "clear".to_string(),
                "compact".to_string(),
                "context".to_string(),
                "add-dir".to_string(),
                // Session management
                "resume".to_string(),
                "memory".to_string(),
                // Model & AI
                "model".to_string(),
                "think".to_string(),
                // Development
                "review".to_string(),
                "commit".to_string(),
                "pr".to_string(),
                // Settings & Config
                "permissions".to_string(),
                "config".to_string(),
                "vim".to_string(),
                // Troubleshooting
                "doctor".to_string(),
                "bug".to_string(),
                // Project setup
                "init".to_string(),
                "terminal-setup".to_string(),
                // MCP
                "mcp".to_string(),
                // Auth
                "login".to_string(),
                "logout".to_string(),
            ], cx);
            // Restore draft if available
            if !saved_draft.is_empty() {
                input.set_text(saved_draft.clone(), cx);
            }
            input
        });

        // Subscribe to input events
        cx.subscribe(&input, |this, _, event: &ChatInputEvent, cx| {
            match event {
                ChatInputEvent::Submit(text) => {
                    cx.emit(ChatViewEvent::Submit(text.clone()));
                }
                ChatInputEvent::FilesAttached(files) => {
                    // Track attached files in context and recent files
                    for file in files {
                        let path = file.to_string_lossy().to_string();
                        this.track_recent_file(path.clone(), cx);
                        this.add_context_file(path.clone(), cx);
                        cx.emit(ChatViewEvent::FileAttached(path));
                    }
                }
                ChatInputEvent::MentionPartial(_partial) => {
                    // Handle partial mention
                }
            }
        })
        .detach();

        Self {
            app_state,
            message_views: Vec::new(),
            messages: Vec::new(),
            input,
            is_streaming: false,
            current_assistant_message: None,
            streaming_message_view: None,
            current_conversation_id: None,
            show_stats: true, // Show by default
            search_query: String::new(),
            show_search: false,
            search_results: Vec::new(),
            current_search_result: 0,
            search_case_sensitive: false,
            search_regex: false,
            search_role_filter: MessageFilter::All,
            show_scroll_to_bottom: false,
            unread_count: 0,
            message_filter: MessageFilter::All,
            show_timestamps: true, // Show by default
            compact_mode: false,
            show_time_separators: true, // Show time group separators by default
            conversation_title: None,
            editing_title: false,
            title_edit_buffer: String::new(),
            title_focus: cx.focus_handle(),
            auto_scroll: true, // Auto-scroll by default
            selected_message_index: None,
            show_bookmarked_only: false,
            word_wrap: false, // No word wrap by default (horizontal scroll)
            show_line_numbers: true, // Show line numbers by default
            session_info: None,
            session_cost: 0.0,
            session_input_tokens: 0,
            session_output_tokens: 0,
            active_tasks: Vec::new(),
            connection_status: ConnectionStatus::Disconnected,
            notifications: Vec::new(),
            show_shortcuts_help: false,
            streaming_dots: 0,
            show_command_palette: false,
            palette_query: String::new(),
            palette_selected_index: 0,
            recent_commands: Vec::new(),
            last_response_time_ms: None,
            response_start_time: None,
            show_model_switcher: false,
            draft_text: if saved_draft.is_empty() { None } else { Some(saved_draft) },
            draft_saved_at: None,
            context_capacity: 200_000, // Default Claude context window
            context_used: 0,
            available_models: ModelInfo::available_models(),
            contextual_suggestions: Vec::new(),
            show_suggestions: true, // Show suggestions by default
            show_fab_menu: false,
            recent_sessions: Vec::new(),
            show_session_history: false,
            last_error: None,
            pending_permissions: Vec::new(),
            show_permissions_panel: false,
            show_mcp_panel: false,
            show_tasks_panel: false,
            git_info: None,
            show_git_panel: false,
            file_picker_visible: false,
            file_picker_query: String::new(),
            file_picker_results: Vec::new(),
            bookmarked_messages: std::collections::HashSet::new(),
            show_bookmarks_only: false,
            multiline_input: false,
            input_height_lines: 3,
            show_session_details: false,
            streaming_token_count: 0,
            last_streaming_speed: 0.0,
            peak_streaming_speed: 0.0,
            total_api_requests: 0,
            show_thinking: true, // Show thinking by default
            current_thinking: None,
            current_tool_name: None,
            expanded_mcp_servers: std::collections::HashSet::new(),
            mcp_server_tools: std::collections::HashMap::new(),
            show_commands_panel: false,
            commands_filter: String::new(),
            commands_category: CommandCategory::All,
            show_templates_panel: false,
            prompt_templates: default_prompt_templates(),
            templates_filter: String::new(),
            show_context_panel: false,
            context_files: Vec::new(),
            show_export_panel: false,
            export_format: ExportFormat::default(),
            export_include_metadata: true,
            export_include_tools: true,
            export_include_thinking: false,
            pinned_messages: std::collections::HashSet::new(),
            edit_history: Vec::new(),
            edit_history_position: 0,
            message_reactions: std::collections::HashMap::new(),
            session_notes: String::new(),
            show_notes_panel: false,
            quick_action_message: None,
            context_menu: None,
            favorite_prompts: Vec::new(),
            show_favorites_panel: false,
            focus_mode: false,
            conversation_tags: Vec::new(),
            show_tags_editor: false,
            quick_reactions: QUICK_REACTIONS.to_vec(),
            show_pinned_panel: false,
            show_quick_settings: false,
            show_stats_panel: false,
            input_history: Vec::new(),
            input_history_position: -1,
            input_history_temp: String::new(),
            input_history_max: 50,
            show_input_hints: true,
            recent_files: Vec::new(),
            show_recent_files_panel: false,
            max_recent_files: 20,
            highlighted_message: None,
            show_message_preview: true,
            navigation_history: Vec::new(),
            navigation_history_position: 0,
            file_drag_active: false,
            drag_file_count: 0,
            session_health: 1.0,
            last_health_check: None,
            show_onboarding_tips: true,
            dismissed_tips: std::collections::HashSet::new(),
            quick_reply_suggestions: Vec::new(),
            show_typing_indicator: true,
            connection_retry_count: 0,
            last_response_latency_ms: None,
            avg_response_latency_ms: 0.0,
            think_mode_enabled: false,
        }
    }

    /// Track a command as recently used
    fn track_recent_command(&mut self, command: &str) {
        // Only track slash commands
        if !command.starts_with('/') {
            return;
        }

        // Remove if already exists (to move to front)
        self.recent_commands.retain(|c| c != command);

        // Add to front
        self.recent_commands.insert(0, command.to_string());

        // Keep only last 10
        self.recent_commands.truncate(10);
    }

    /// Start tracking response time
    fn start_response_timer(&mut self) {
        self.response_start_time = Some(chrono::Utc::now());
    }

    /// Stop tracking response time and record duration
    fn stop_response_timer(&mut self) {
        if let Some(start) = self.response_start_time.take() {
            let duration = chrono::Utc::now().signed_duration_since(start);
            self.last_response_time_ms = Some(duration.num_milliseconds() as u64);
        }
    }

    /// Toggle model switcher dropdown
    pub fn toggle_model_switcher(&mut self, cx: &mut Context<Self>) {
        self.show_model_switcher = !self.show_model_switcher;
        cx.notify();
    }

    // current_session_id method moved to session.rs

    /// Select a model and send the /model command
    pub fn select_model(&mut self, model_id: &str, cx: &mut Context<Self>) {
        self.show_model_switcher = false;
        // Update available_models to mark the selected one as current
        for model in &mut self.available_models {
            model.is_current = model.id == model_id;
        }
        // Send the model switch command
        cx.emit(ChatViewEvent::Submit(format!("/model {}", model_id)));
        cx.notify();
    }

    /// Save current input as draft (persists to settings)
    pub fn save_draft(&mut self, text: String, cx: &mut Context<Self>) {
        if !text.is_empty() {
            self.draft_text = Some(text.clone());
            self.draft_saved_at = Some(chrono::Utc::now());
            // Persist to settings and save to disk
            self.app_state.settings.update(cx, |settings, _| {
                settings.draft_text = text;
                let _ = settings.save(); // Best-effort save
            });
        } else {
            self.draft_text = None;
            self.draft_saved_at = None;
            // Clear from settings and save to disk
            self.app_state.settings.update(cx, |settings, _| {
                settings.draft_text.clear();
                let _ = settings.save(); // Best-effort save
            });
        }
        cx.notify();
    }

    /// Clear the saved draft (and persist)
    pub fn clear_draft(&mut self, cx: &mut Context<Self>) {
        self.draft_text = None;
        self.draft_saved_at = None;
        // Clear from settings and save to disk
        self.app_state.settings.update(cx, |settings, _| {
            settings.draft_text.clear();
            let _ = settings.save(); // Best-effort save
        });
        cx.notify();
    }

    /// Get draft text if available
    pub fn get_draft(&self) -> Option<&str> {
        self.draft_text.as_deref()
    }

    /// Check if there's a saved draft
    pub fn has_draft(&self) -> bool {
        self.draft_text.is_some()
    }

    /// Load draft from settings (call on startup)
    pub fn restore_draft_from_settings(&mut self, cx: &mut Context<Self>) {
        let draft = self.app_state.settings.read(cx).draft_text.clone();
        if !draft.is_empty() {
            self.draft_text = Some(draft.clone());
            self.draft_saved_at = None; // Don't know when it was saved
            // Set the text in the input
            self.input.update(cx, |input, cx| {
                input.set_text(draft, cx);
            });
            cx.notify();
        }
    }

    /// Sync current input text to draft (call before closing or periodically)
    pub fn sync_draft_to_settings(&mut self, cx: &mut Context<Self>) {
        let current_text = self.input.read(cx).text().to_string();
        if current_text != self.draft_text.as_deref().unwrap_or("") {
            self.save_draft(current_text, cx);
        }
    }

    /// Update context usage based on token counts
    pub fn update_context_usage(&mut self, used: u64, capacity: Option<u64>, cx: &mut Context<Self>) {
        let old_percentage = self.context_usage_percentage();

        self.context_used = used;
        if let Some(cap) = capacity {
            self.context_capacity = cap;
        }

        let new_percentage = self.context_usage_percentage();

        // Show proactive warnings when crossing thresholds
        if old_percentage <= 0.70 && new_percentage > 0.70 {
            self.show_notification(
                "Context is 70% full. Consider using /compact to free space.",
                NotificationType::Info,
                cx
            );
        } else if old_percentage <= 0.85 && new_percentage > 0.85 {
            self.show_notification(
                "Context is 85% full! Use /compact soon to avoid losing context.",
                NotificationType::Warning,
                cx
            );
        } else if old_percentage <= 0.95 && new_percentage > 0.95 {
            self.show_notification(
                "Context almost full! Use /compact immediately to prevent issues.",
                NotificationType::Error,
                cx
            );
        }

        // Recalculate session health when context changes significantly
        if (new_percentage - old_percentage).abs() > 0.05 {
            self.calculate_session_health(cx);
        }

        cx.notify();
    }

    // context_usage_percentage method moved to session.rs

    /// Get context usage status color based on percentage
    pub(crate) fn context_status_color(&self, theme: &crate::app::theme::Theme) -> gpui::Hsla {
        let percentage = self.context_usage_percentage();
        if percentage > 0.95 {
            theme.colors.error
        } else if percentage > 0.80 {
            theme.colors.warning
        } else if percentage > 0.60 {
            theme.colors.info
        } else {
            theme.colors.success
        }
    }

    /// Get context usage warning message if needed
    pub(crate) fn context_warning_message(&self) -> Option<&'static str> {
        let percentage = self.context_usage_percentage();
        if percentage > 0.95 {
            Some("Context almost full! Consider using /compact")
        } else if percentage > 0.80 {
            Some("Context filling up. Consider compacting soon.")
        } else {
            None
        }
    }

    /// Format context usage for display
    pub fn format_context_usage(&self) -> String {
        let percentage = (self.context_usage_percentage() * 100.0) as u32;
        let used = if self.context_used >= 1000 {
            format!("{:.1}K", self.context_used as f64 / 1000.0)
        } else {
            self.context_used.to_string()
        };
        let capacity = if self.context_capacity >= 1000 {
            format!("{:.0}K", self.context_capacity as f64 / 1000.0)
        } else {
            self.context_capacity.to_string()
        };
        format!("{}/{}  ({}%)", used, capacity, percentage)
    }

    // ==================== Contextual Suggestions ====================
    // Moved to suggestions.rs: update_suggestions, toggle_suggestions, use_suggestion

    /// Toggle floating action button menu
    pub fn toggle_fab_menu(&mut self, cx: &mut Context<Self>) {
        self.show_fab_menu = !self.show_fab_menu;
        cx.notify();
    }

    // Moved to suggestions.rs: get_smart_commands

    /// Get command description for autocomplete
    pub fn get_command_description(command: &str) -> Option<&'static str> {
        match command {
            // Core commands
            "/help" => Some("Show available commands and usage"),
            "/compact" => Some("Compact conversation to free context tokens"),
            "/usage" | "/cost" => Some("Show token usage and estimated costs"),
            "/clear" => Some("Clear the conversation context"),
            "/model" => Some("Switch to a different AI model"),
            "/think" => Some("Enable extended thinking mode for deep analysis"),
            "/memory" => Some("View and edit persistent memory"),
            "/doctor" => Some("Run diagnostics check"),
            "/init" => Some("Initialize project configuration"),
            "/add-dir" => Some("Add directory to context"),
            "/permissions" => Some("Manage tool permissions"),
            "/config" => Some("View configuration settings"),
            "/resume" => Some("Resume previous session"),
            "/bug" => Some("Report a bug"),
            "/mcp" => Some("Manage MCP servers"),
            "/vim" => Some("Toggle vim keybindings"),
            "/login" => Some("Authenticate with Anthropic"),
            "/logout" => Some("Log out from Anthropic"),
            "/status" => Some("Show git repository status"),

            // Claude Code Skills
            "/apex" => Some("APEX workflow: Analyze-Plan-Execute-eXamine"),
            "/brainstorm" => Some("Deep iterative research with skeptical analysis"),
            "/explore" => Some("Deep codebase exploration and understanding"),
            "/debug" => Some("Systematic error debugging and resolution"),
            "/review" => Some("Deep code review with parallel analysis"),
            "/oneshot" => Some("Ultra-fast feature implementation"),
            "/explain" => Some("Deep code explanation with visual diagrams"),
            "/refactor" => Some("Refactor code with parallel agents"),
            "/docs" => Some("Deep documentation research"),
            "/ultrathink" => Some("Deep thinking mode for elegant solutions"),
            "/search" => Some("Lightning-fast search for specific questions"),

            // Git commands
            "/commit" => Some("Create commit with smart message"),
            "/pr" | "/create-pr" => Some("Create and push pull request"),
            "/fix-pr-comments" => Some("Fetch and implement PR review comments"),
            "/merge" => Some("Intelligent merge with conflict resolution"),

            // Other utilities
            "/test" => Some("Generate comprehensive tests"),
            "/summarize" => Some("Summarize the conversation"),

            _ => None,
        }
    }

    // Moved to suggestions.rs: get_contextual_placeholder, get_quick_actions

    // ==================== Session History ====================
    // Session history methods moved to session.rs:
    // - toggle_session_history
    // - add_recent_session
    // - resume_session
    // - resume_last_session

    /// Send a slash command to Claude Code
    pub fn send_slash_command(&mut self, command: &str, cx: &mut Context<Self>) {
        let cmd = if command.starts_with('/') {
            command.to_string()
        } else {
            format!("/{}", command)
        };

        // Show feedback notification for common Claude Code commands
        let notification = match cmd.split_whitespace().next().unwrap_or("") {
            // Core Claude Code commands
            "/think" => Some(("ðŸ§  Entering deep thinking mode...", NotificationType::Info)),
            "/review" => Some(("ðŸ‘€ Starting code review...", NotificationType::Info)),
            "/commit" => Some(("ðŸ“¦ Preparing smart commit...", NotificationType::Info)),
            "/memory" => Some(("ðŸ’¾ Loading memory...", NotificationType::Info)),
            "/compact" => Some(("ðŸ—œï¸ Compacting context...", NotificationType::Info)),
            "/debug" => Some(("ðŸ› Starting debug analysis...", NotificationType::Info)),
            "/test" => Some(("ðŸ§ª Generating tests...", NotificationType::Info)),
            "/resume" => Some(("â–¶ï¸ Resuming session...", NotificationType::Info)),
            "/status" => Some(("ðŸ“Š Checking git status...", NotificationType::Info)),
            "/add-dir" => Some(("ðŸ“ Adding directory to context...", NotificationType::Info)),

            // Claude Code Skills
            "/apex" => Some(("âš¡ Starting APEX workflow (Analyze-Plan-Execute-eXamine)...", NotificationType::Info)),
            "/brainstorm" => Some(("ðŸ’¡ Starting deep research mode...", NotificationType::Info)),
            "/explore" => Some(("ðŸ” Exploring codebase...", NotificationType::Info)),
            "/oneshot" => Some(("ðŸš€ Ultra-fast implementation mode...", NotificationType::Info)),
            "/explain" => Some(("ðŸ“– Generating deep explanation...", NotificationType::Info)),
            "/refactor" => Some(("â™»ï¸ Starting parallel refactoring...", NotificationType::Info)),
            "/docs" => Some(("ðŸ“š Researching documentation...", NotificationType::Info)),
            "/ultrathink" => Some(("ðŸ§  Entering ultra-deep thinking mode...", NotificationType::Info)),

            // Git Skills
            "/create-pr" | "/pr" => Some(("ðŸ”€ Creating pull request...", NotificationType::Info)),
            "/fix-pr-comments" => Some(("ðŸ’¬ Fetching and fixing PR comments...", NotificationType::Info)),
            "/merge" => Some(("ðŸ”— Starting intelligent merge...", NotificationType::Info)),

            // Other utilities
            "/help" => Some(("â“ Loading available commands...", NotificationType::Info)),
            "/usage" | "/cost" => Some(("ðŸ“Š Calculating token usage...", NotificationType::Info)),
            "/doctor" => Some(("ðŸ©º Running diagnostics...", NotificationType::Info)),
            "/mcp" => Some(("ðŸ”Œ Managing MCP servers...", NotificationType::Info)),
            "/permissions" => Some(("ðŸ” Loading permissions...", NotificationType::Info)),
            "/init" => Some(("ðŸš€ Initializing project...", NotificationType::Info)),
            "/clear" => Some(("ðŸ—‘ï¸ Clearing conversation...", NotificationType::Warning)),

            _ => None,
        };

        if let Some((msg, notification_type)) = notification {
            self.show_notification(msg, notification_type, cx);
        }

        cx.emit(ChatViewEvent::Submit(cmd));
    }

    // ==================== Error Handling ====================

    /// Record an error for potential retry
    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    // Moved to errors.rs

    /// Send a Claude Code tool command
    pub fn send_tool_command(&mut self, tool: &str, args: Option<&str>, cx: &mut Context<Self>) {
        let cmd = if let Some(args) = args {
            format!("@{} {}", tool, args)
        } else {
            format!("@{}", tool)
        };
        cx.emit(ChatViewEvent::Submit(cmd));
    }

    /// Request code review
    pub fn request_code_review(&mut self, cx: &mut Context<Self>) {
        self.send_slash_command("/review", cx);
        self.show_notification("Requesting code review...", NotificationType::Info, cx);
    }

    /// Create a PR
    pub fn create_pr(&mut self, cx: &mut Context<Self>) {
        self.send_slash_command("/pr", cx);
        self.show_notification("Creating pull request...", NotificationType::Info, cx);
    }

    /// Show PR comments
    pub fn show_pr_comments(&mut self, cx: &mut Context<Self>) {
        self.send_slash_command("/pr-comments", cx);
    }

    // show_cost method moved to session.rs

    /// Show status
    pub fn show_status(&mut self, cx: &mut Context<Self>) {
        self.send_slash_command("/status", cx);
    }

    /// Enable extended thinking mode
    pub fn enable_think_mode(&mut self, cx: &mut Context<Self>) {
        self.think_mode_enabled = true;
        self.send_slash_command("/think", cx);
        self.show_notification("Extended thinking enabled - Claude will reason more deeply", NotificationType::Info, cx);
        cx.notify();
    }

    /// Disable extended thinking mode
    pub fn disable_think_mode(&mut self, cx: &mut Context<Self>) {
        self.think_mode_enabled = false;
        self.send_slash_command("/think off", cx);
        self.show_notification("Extended thinking disabled", NotificationType::Info, cx);
        cx.notify();
    }

    /// Toggle extended thinking mode
    pub fn toggle_think_mode(&mut self, cx: &mut Context<Self>) {
        if self.think_mode_enabled {
            self.disable_think_mode(cx);
        } else {
            self.enable_think_mode(cx);
        }
    }

    /// Check if think mode is enabled
    pub fn is_think_mode_enabled(&self) -> bool {
        self.think_mode_enabled
    }

    // ==================== Permissions ====================

    /// Toggle permissions panel
    pub fn toggle_permissions_panel(&mut self, cx: &mut Context<Self>) {
        self.show_permissions_panel = !self.show_permissions_panel;
        cx.notify();
    }

    /// Add a pending permission request
    pub fn add_permission_request(&mut self, request: PermissionRequest, cx: &mut Context<Self>) {
        self.pending_permissions.push(request);
        cx.notify();
    }

    /// Approve a permission request
    pub fn approve_permission(&mut self, index: usize, cx: &mut Context<Self>) {
        if index < self.pending_permissions.len() {
            let _request = self.pending_permissions.remove(index);
            // TODO: Actually approve the permission via Claude CLI
            self.show_notification("Permission approved", NotificationType::Success, cx);
        }
    }

    /// Deny a permission request
    pub fn deny_permission(&mut self, index: usize, cx: &mut Context<Self>) {
        if index < self.pending_permissions.len() {
            let _request = self.pending_permissions.remove(index);
            self.show_notification("Permission denied", NotificationType::Info, cx);
        }
    }

    /// Approve all pending permission requests
    pub fn approve_all_permissions(&mut self, cx: &mut Context<Self>) {
        let count = self.pending_permissions.len();
        if count > 0 {
            self.pending_permissions.clear();
            self.show_notification(
                &format!("Approved {} permission{}", count, if count == 1 { "" } else { "s" }),
                NotificationType::Success,
                cx
            );
        }
    }

    /// Deny all pending permission requests
    pub fn deny_all_permissions(&mut self, cx: &mut Context<Self>) {
        let count = self.pending_permissions.len();
        if count > 0 {
            self.pending_permissions.clear();
            self.show_notification(
                &format!("Denied {} permission{}", count, if count == 1 { "" } else { "s" }),
                NotificationType::Info,
                cx
            );
        }
    }

    /// Check if there are pending permissions
    pub fn has_pending_permissions(&self) -> bool {
        !self.pending_permissions.is_empty()
    }

    // ==================== MCP Servers ====================

    /// Toggle MCP servers panel
    pub fn toggle_mcp_panel(&mut self, cx: &mut Context<Self>) {
        self.show_mcp_panel = !self.show_mcp_panel;
        cx.notify();
    }

    /// Get MCP server count
    pub fn mcp_server_count(&self) -> usize {
        self.session_info.as_ref()
            .map(|info| info.mcp_servers.len())
            .unwrap_or(0)
    }

    /// Toggle MCP server expansion in panel
    pub fn toggle_mcp_server_expanded(&mut self, server_name: &str, cx: &mut Context<Self>) {
        if self.expanded_mcp_servers.contains(server_name) {
            self.expanded_mcp_servers.remove(server_name);
        } else {
            self.expanded_mcp_servers.insert(server_name.to_string());
        }
        cx.notify();
    }

    /// Check if an MCP server is expanded
    pub fn is_mcp_server_expanded(&self, server_name: &str) -> bool {
        self.expanded_mcp_servers.contains(server_name)
    }

    /// Get tools for MCP server (from session tools that match server prefix)
    pub fn get_mcp_server_tools(&self, server_name: &str) -> Vec<String> {
        // MCP tools are typically prefixed with server name, e.g., "mcp__serverName__toolName"
        self.session_info.as_ref()
            .map(|info| {
                info.tools.iter()
                    .filter(|tool| {
                        let tool_lower = tool.to_lowercase();
                        let server_lower = server_name.to_lowercase();
                        tool_lower.contains(&format!("mcp__{}", server_lower)) ||
                        tool_lower.starts_with(&format!("{}:", server_lower)) ||
                        tool_lower.starts_with(&format!("{}_", server_lower))
                    })
                    .cloned()
                    .collect()
            })
            .unwrap_or_default()
    }

    /// Use MCP server tool - insert prompt suggestion
    pub fn use_mcp_tool(&mut self, tool_name: &str, cx: &mut Context<Self>) {
        let prompt = format!("Use the {} tool to ", tool_name);
        self.input.update(cx, |input, cx| {
            input.clear(cx);
            input.insert_text(&prompt, cx);
        });
        self.show_mcp_panel = false;
        cx.notify();
    }

    // ==================== Commands Panel ====================

    /// Toggle commands panel
    pub fn toggle_commands_panel(&mut self, cx: &mut Context<Self>) {
        self.show_commands_panel = !self.show_commands_panel;
        if !self.show_commands_panel {
            self.commands_filter.clear();
        }
        cx.notify();
    }

    /// Set commands filter
    pub fn set_commands_filter(&mut self, filter: String, cx: &mut Context<Self>) {
        self.commands_filter = filter;
        cx.notify();
    }

    /// Set commands category filter
    pub fn set_commands_category(&mut self, category: CommandCategory, cx: &mut Context<Self>) {
        self.commands_category = category;
        cx.notify();
    }

    /// Get filtered commands based on current filter and category
    pub fn filtered_commands(&self) -> (Vec<String>, Vec<String>) {
        let filter = self.commands_filter.to_lowercase();
        let session = self.session_info.as_ref();

        let slash_commands: Vec<String> = session
            .map(|info| {
                info.slash_commands.iter()
                    .filter(|cmd| filter.is_empty() || cmd.to_lowercase().contains(&filter))
                    .cloned()
                    .collect()
            })
            .unwrap_or_default();

        let skills: Vec<String> = session
            .map(|info| {
                info.skills.iter()
                    .filter(|skill| filter.is_empty() || skill.to_lowercase().contains(&filter))
                    .cloned()
                    .collect()
            })
            .unwrap_or_default();

        (slash_commands, skills)
    }

    /// Use a slash command
    pub fn use_slash_command(&mut self, command: &str, cx: &mut Context<Self>) {
        let cmd = if command.starts_with('/') {
            command.to_string()
        } else {
            format!("/{}", command)
        };
        self.input.update(cx, |input, cx| {
            input.clear(cx);
            input.insert_text(&cmd, cx);
        });
        self.show_commands_panel = false;
        cx.notify();
    }

    /// Use a skill
    pub fn use_skill(&mut self, skill: &str, cx: &mut Context<Self>) {
        let cmd = format!("/{}", skill);
        self.input.update(cx, |input, cx| {
            input.clear(cx);
            input.insert_text(&cmd, cx);
        });
        self.show_commands_panel = false;
        cx.notify();
    }

    // ==================== Prompt Templates ====================

    /// Toggle templates panel
    pub fn toggle_templates_panel(&mut self, cx: &mut Context<Self>) {
        self.show_templates_panel = !self.show_templates_panel;
        if !self.show_templates_panel {
            self.templates_filter.clear();
        }
        cx.notify();
    }

    /// Set templates filter
    pub fn set_templates_filter(&mut self, filter: String, cx: &mut Context<Self>) {
        self.templates_filter = filter;
        cx.notify();
    }

    /// Get filtered templates
    pub fn filtered_templates(&self) -> Vec<&PromptTemplate> {
        let filter = self.templates_filter.to_lowercase();
        self.prompt_templates
            .iter()
            .filter(|t| {
                filter.is_empty() ||
                t.name.to_lowercase().contains(&filter) ||
                t.content.to_lowercase().contains(&filter) ||
                t.category.to_lowercase().contains(&filter)
            })
            .collect()
    }

    /// Use a template - insert its content into input
    pub fn use_template(&mut self, template_id: &str, cx: &mut Context<Self>) {
        if let Some(template) = self.prompt_templates.iter_mut().find(|t| t.id == template_id) {
            template.usage_count += 1;
            let content = template.content.clone();
            self.input.update(cx, |input, cx| {
                input.insert_text(&content, cx);
            });
        }
        self.show_templates_panel = false;
        cx.notify();
    }

    /// Save current input as a new template
    pub fn save_as_template(&mut self, name: String, cx: &mut Context<Self>) {
        let content = self.input.read(cx).text();
        if !content.is_empty() && !name.is_empty() {
            let template = PromptTemplate::new(name, content, "custom", "ðŸ“Œ");
            self.prompt_templates.push(template);
            self.show_notification("Template saved!", NotificationType::Success, cx);
        }
        cx.notify();
    }

    /// Delete a custom template
    pub fn delete_template(&mut self, template_id: &str, cx: &mut Context<Self>) {
        self.prompt_templates.retain(|t| t.id != template_id || t.is_builtin);
        cx.notify();
    }

    /// Get templates grouped by category
    pub fn templates_by_category(&self) -> std::collections::HashMap<&'static str, Vec<&PromptTemplate>> {
        let mut groups: std::collections::HashMap<&'static str, Vec<&PromptTemplate>> = std::collections::HashMap::new();
        let filter = self.templates_filter.to_lowercase();

        for template in &self.prompt_templates {
            if filter.is_empty() ||
               template.name.to_lowercase().contains(&filter) ||
               template.content.to_lowercase().contains(&filter) {
                groups.entry(template.category).or_default().push(template);
            }
        }

        groups
    }

    // ==================== Context Panel ====================
    // Context panel methods moved to context.rs:
    // - toggle_context_panel
    // - add_context_file, remove_context_file, clear_context_files
    // - context_files_tokens, context_file_count

    // ==================== Recent Files ====================
    // Recent files methods moved to context.rs:
    // - toggle_recent_files_panel
    // - track_recent_file
    // - recent_files_count, clear_recent_files
    // - add_recent_file_to_context
    // - insert_file_mention

    // ==================== Active Tasks ====================

    /// Toggle active tasks panel
    pub fn toggle_tasks_panel(&mut self, cx: &mut Context<Self>) {
        self.show_tasks_panel = !self.show_tasks_panel;
        cx.notify();
    }

    /// Get active task count
    pub fn active_task_count(&self) -> usize {
        self.active_tasks.len()
    }

    /// Update task progress
    pub fn update_task_progress(&mut self, task_id: &str, progress: u8, status: Option<String>, cx: &mut Context<Self>) {
        if let Some(task) = self.active_tasks.iter_mut().find(|t| t.task_id.as_deref() == Some(task_id)) {
            task.progress = Some(progress.min(100));
            task.status = status;
            cx.notify();
        }
    }

    /// Cancel a task by ID (or first task if None)
    pub fn cancel_task(&mut self, task_id: Option<String>, cx: &mut Context<Self>) {
        if let Some(id) = task_id {
            if let Some(pos) = self.active_tasks.iter().position(|t| t.task_id.as_ref() == Some(&id)) {
                let task = self.active_tasks.remove(pos);
                self.show_notification(
                    &format!("Cancelled task: {}", task.description),
                    NotificationType::Info,
                    cx
                );
                // Emit the cancel event
                cx.emit(ChatViewEvent::CancelTask(Some(id)));
            }
        } else if !self.active_tasks.is_empty() {
            // Cancel first task
            let task = self.active_tasks.remove(0);
            self.show_notification(
                &format!("Cancelled task: {}", task.description),
                NotificationType::Info,
                cx
            );
            cx.emit(ChatViewEvent::CancelTask(task.task_id));
        }
    }

    // ==================== Git Integration ====================

    /// Toggle git panel
    pub fn toggle_git_panel(&mut self, cx: &mut Context<Self>) {
        self.show_git_panel = !self.show_git_panel;
        cx.notify();
    }

    /// Update git info
    pub fn update_git_info(&mut self, info: GitInfo, cx: &mut Context<Self>) {
        self.git_info = Some(info);
        cx.notify();
    }

    /// Clear git info
    pub fn clear_git_info(&mut self, cx: &mut Context<Self>) {
        self.git_info = None;
        cx.notify();
    }

    /// Request a git status refresh from the workspace
    pub fn refresh_git_status(&mut self, cx: &mut Context<Self>) {
        cx.emit(ChatViewEvent::RefreshGitStatus);
    }

    // ==================== File Picker ====================
    // File picker methods moved to context.rs:
    // - toggle_file_picker
    // - update_file_picker_query
    // - select_file

    // ==================== Bookmarks ====================
    // Bookmark methods moved to messages.rs:
    // - toggle_bookmark, is_bookmarked
    // - jump_to_next_bookmark, jump_to_prev_bookmark
    // - get_bookmarked_indices, get_bookmarked_messages
    // - bookmarked_count, toggle_bookmarked_only
    // - toggle_bookmarked_filter, is_bookmarked_filter_active
    // - bookmarked_message_count

    // Input handlers moved to handlers.rs:
    // - toggle_multiline_input, increase_input_height, decrease_input_height
    // - toggle_input_hints

    // toggle_session_details method moved to session.rs

    /// Toggle thinking/reasoning display
    pub fn toggle_thinking(&mut self, cx: &mut Context<Self>) {
        self.show_thinking = !self.show_thinking;
        cx.notify();
    }

    // Streaming metrics methods moved to claude_events.rs:
    // - update_streaming_speed
    // - reset_streaming_metrics

    /// Get formatted streaming speed
    pub fn format_streaming_speed(&self) -> String {
        if self.last_streaming_speed > 0.0 {
            format!("{:.1} tok/s", self.last_streaming_speed)
        } else {
            "-".to_string()
        }
    }

    /// Get all available commands for the command palette
    pub(crate) fn get_palette_commands() -> Vec<PaletteCommand> {
        vec![
            // Navigation
            PaletteCommand { id: "scroll_to_top", label: "Go to First Message", description: "Navigate to the first message", shortcut: Some("âŒ¥Home"), category: "Navigation", icon: "â¬†" },
            PaletteCommand { id: "scroll_to_bottom", label: "Go to Last Message", description: "Navigate to the last message", shortcut: Some("âŒ¥End"), category: "Navigation", icon: "â¬‡" },
            PaletteCommand { id: "prev_message", label: "Previous Message", description: "Select the previous message", shortcut: Some("âŒ¥â†‘"), category: "Navigation", icon: "â†‘" },
            PaletteCommand { id: "next_message", label: "Next Message", description: "Select the next message", shortcut: Some("âŒ¥â†“"), category: "Navigation", icon: "â†“" },
            PaletteCommand { id: "navigate_back", label: "Navigate Back", description: "Go to previously viewed message", shortcut: Some("âŒ˜["), category: "Navigation", icon: "â—€" },
            PaletteCommand { id: "navigate_forward", label: "Navigate Forward", description: "Go to next viewed message", shortcut: Some("âŒ˜]"), category: "Navigation", icon: "â–¶" },
            PaletteCommand { id: "jump_to_search_result", label: "Jump to Search Result", description: "Scroll to and highlight current search result", shortcut: Some("Enter"), category: "Navigation", icon: "â†µ" },

            // View
            PaletteCommand { id: "toggle_search", label: "Search in Conversation", description: "Find text in messages", shortcut: Some("âŒ˜F"), category: "View", icon: "ðŸ”" },
            PaletteCommand { id: "toggle_stats", label: "Toggle Statistics Bar", description: "Show/hide token usage stats", shortcut: Some("âŒ˜I"), category: "View", icon: "ðŸ“Š" },
            PaletteCommand { id: "toggle_timestamps", label: "Toggle Timestamps", description: "Show/hide message timestamps", shortcut: None, category: "View", icon: "ðŸ•" },
            PaletteCommand { id: "toggle_time_separators", label: "Toggle Time Separators", description: "Show/hide date separators between messages", shortcut: None, category: "View", icon: "ðŸ“…" },
            PaletteCommand { id: "toggle_compact", label: "Toggle Compact Mode", description: "Switch to compact view", shortcut: None, category: "View", icon: "ðŸ“" },
            PaletteCommand { id: "toggle_word_wrap", label: "Toggle Word Wrap", description: "Wrap long lines", shortcut: Some("âŒ¥W"), category: "View", icon: "â†©" },
            PaletteCommand { id: "toggle_line_numbers", label: "Toggle Line Numbers", description: "Show/hide line numbers in code", shortcut: Some("âŒ¥L"), category: "View", icon: "#" },
            PaletteCommand { id: "toggle_theme", label: "Toggle Theme", description: "Switch between light/dark mode", shortcut: Some("â‡§âŒ˜T"), category: "View", icon: "ðŸŒ“" },

            // Actions
            PaletteCommand { id: "copy_conversation", label: "Copy Conversation", description: "Copy all messages to clipboard", shortcut: Some("â‡§âŒ˜C"), category: "Actions", icon: "ðŸ“‹" },
            PaletteCommand { id: "copy_last_response", label: "Copy Last Response", description: "Copy Claude's last response", shortcut: Some("âŒ¥â‡§C"), category: "Actions", icon: "ðŸ“‹" },
            PaletteCommand { id: "export_conversation", label: "Export Conversation", description: "Export with format options", shortcut: Some("âŒ˜E"), category: "Actions", icon: "ðŸ’¾" },
            PaletteCommand { id: "clear_conversation", label: "Clear Conversation", description: "Start a new conversation", shortcut: None, category: "Actions", icon: "ðŸ—‘" },
            PaletteCommand { id: "copy_selected", label: "Copy Selected Message", description: "Copy the selected message", shortcut: Some("âŒ¥C"), category: "Actions", icon: "ðŸ“„" },
            PaletteCommand { id: "bookmark_selected", label: "Bookmark Message", description: "Toggle bookmark on selected", shortcut: Some("âŒ¥B"), category: "Actions", icon: "â­" },
            PaletteCommand { id: "edit_last_message", label: "Edit Last Message", description: "Edit your last message", shortcut: Some("âŒ¥âŽ"), category: "Actions", icon: "âœï¸" },
            PaletteCommand { id: "pin_selected", label: "Pin Message", description: "Pin/unpin selected message", shortcut: Some("âŒ¥P"), category: "Actions", icon: "ðŸ“Œ" },

            // Messages
            PaletteCommand { id: "expand_all", label: "Expand All Messages", description: "Expand all collapsed messages", shortcut: None, category: "Messages", icon: "ðŸ“‚" },
            PaletteCommand { id: "collapse_all", label: "Collapse All Messages", description: "Collapse all messages", shortcut: None, category: "Messages", icon: "ðŸ“" },
            PaletteCommand { id: "collapse_tools", label: "Collapse Tool Messages", description: "Collapse all tool use/result messages", shortcut: Some("âŒ¥â‡§T"), category: "Messages", icon: "ðŸ”§" },
            PaletteCommand { id: "expand_tools", label: "Expand Tool Messages", description: "Expand all tool use/result messages", shortcut: None, category: "Messages", icon: "ðŸ”§" },
            PaletteCommand { id: "toggle_tools", label: "Toggle Tool Messages", description: "Toggle collapse state of tool messages", shortcut: None, category: "Messages", icon: "ðŸ”§" },
            PaletteCommand { id: "collapse_assistant", label: "Collapse Claude Messages", description: "Collapse all assistant messages", shortcut: None, category: "Messages", icon: "ðŸ¤–" },
            PaletteCommand { id: "expand_assistant", label: "Expand Claude Messages", description: "Expand all assistant messages", shortcut: None, category: "Messages", icon: "ðŸ¤–" },
            PaletteCommand { id: "filter_all", label: "Show All Messages", description: "Remove message filters", shortcut: None, category: "Messages", icon: "ðŸ‘" },
            PaletteCommand { id: "filter_user", label: "Show User Messages Only", description: "Filter to your messages", shortcut: None, category: "Messages", icon: "ðŸ‘¤" },
            PaletteCommand { id: "filter_assistant", label: "Show Claude Messages Only", description: "Filter to Claude's responses", shortcut: None, category: "Messages", icon: "ðŸ¤–" },
            PaletteCommand { id: "filter_tools", label: "Show Tool Messages Only", description: "Filter to tool use/results", shortcut: None, category: "Messages", icon: "ðŸ”§" },

            // Claude CLI Commands
            PaletteCommand { id: "cmd_resume", label: "/resume", description: "Resume a previous conversation", shortcut: None, category: "Commands", icon: "â†©" },
            PaletteCommand { id: "cmd_usage", label: "/usage", description: "Show token usage and costs", shortcut: None, category: "Commands", icon: "ðŸ“Š" },
            PaletteCommand { id: "cmd_help", label: "/help", description: "Show available commands", shortcut: None, category: "Commands", icon: "â“" },
            PaletteCommand { id: "cmd_config", label: "/config", description: "Open configuration", shortcut: None, category: "Commands", icon: "âš™" },
            PaletteCommand { id: "cmd_memory", label: "/memory", description: "Manage persistent memory", shortcut: None, category: "Commands", icon: "ðŸ§ " },
            PaletteCommand { id: "cmd_model", label: "/model", description: "Switch AI model", shortcut: None, category: "Commands", icon: "ðŸ”„" },
            PaletteCommand { id: "cmd_compact", label: "/compact", description: "Compact conversation context", shortcut: None, category: "Commands", icon: "ðŸ“¦" },
            PaletteCommand { id: "cmd_vim", label: "/vim", description: "Toggle vim mode", shortcut: None, category: "Commands", icon: "âŒ¨" },
            PaletteCommand { id: "cmd_doctor", label: "/doctor", description: "Run diagnostics check", shortcut: None, category: "Commands", icon: "ðŸ©º" },
            PaletteCommand { id: "cmd_permissions", label: "/permissions", description: "Manage tool permissions", shortcut: None, category: "Commands", icon: "ðŸ”" },
            PaletteCommand { id: "cmd_init", label: "/init", description: "Initialize project setup", shortcut: None, category: "Commands", icon: "ðŸš€" },
            PaletteCommand { id: "cmd_add_dir", label: "/add-dir", description: "Add directory to context", shortcut: None, category: "Commands", icon: "ðŸ“" },
            PaletteCommand { id: "cmd_clear", label: "/clear", description: "Clear conversation context", shortcut: None, category: "Commands", icon: "ðŸ—‘" },
            PaletteCommand { id: "cmd_cost", label: "/cost", description: "Show cost breakdown", shortcut: None, category: "Commands", icon: "ðŸ’°" },
            PaletteCommand { id: "cmd_status", label: "/status", description: "Show session status", shortcut: None, category: "Commands", icon: "ðŸ“Š" },
            PaletteCommand { id: "cmd_think", label: "/think", description: "Enable extended thinking mode", shortcut: None, category: "Commands", icon: "ðŸ§ " },
            PaletteCommand { id: "cmd_think_off", label: "/think off", description: "Disable extended thinking mode", shortcut: None, category: "Commands", icon: "ðŸ’­" },
            PaletteCommand { id: "toggle_think", label: "Toggle Think Mode", description: "Toggle extended thinking on/off", shortcut: Some("âŒ¥T"), category: "Workflow", icon: "ðŸ§ " },
            PaletteCommand { id: "cmd_review", label: "/review", description: "Request code review", shortcut: None, category: "Commands", icon: "ðŸ‘€" },
            PaletteCommand { id: "cmd_pr", label: "/pr", description: "Create a pull request", shortcut: None, category: "Commands", icon: "ðŸ”€" },
            PaletteCommand { id: "cmd_pr_comments", label: "/pr-comments", description: "Show PR review comments", shortcut: None, category: "Commands", icon: "ðŸ’¬" },
            PaletteCommand { id: "cmd_login", label: "/login", description: "Authenticate with Anthropic", shortcut: None, category: "Commands", icon: "ðŸ”‘" },
            PaletteCommand { id: "cmd_logout", label: "/logout", description: "Log out from Anthropic", shortcut: None, category: "Commands", icon: "ðŸšª" },
            PaletteCommand { id: "cmd_bug", label: "/bug", description: "Report a bug", shortcut: None, category: "Commands", icon: "ðŸ›" },
            PaletteCommand { id: "cmd_mcp", label: "/mcp", description: "Manage MCP servers", shortcut: None, category: "Commands", icon: "ðŸ”Œ" },

            // Response Actions
            PaletteCommand { id: "continue_response", label: "Continue Response", description: "Ask Claude to continue from where it stopped", shortcut: Some("âŒ¥C"), category: "Actions", icon: "â–¶" },
            PaletteCommand { id: "regenerate_response", label: "Regenerate Response", description: "Regenerate Claude's last response", shortcut: Some("âŒ˜â‡§R"), category: "Actions", icon: "ðŸ”„" },

            // Model switching
            PaletteCommand { id: "switch_model", label: "Switch Model", description: "Change the AI model", shortcut: Some("âŒ˜M"), category: "Model", icon: "ðŸ¤–" },

            // Templates
            PaletteCommand { id: "show_templates", label: "Prompt Templates", description: "Browse and use prompt templates", shortcut: Some("âŒ˜T"), category: "Input", icon: "ðŸ“" },
            PaletteCommand { id: "show_commands", label: "Commands & Skills", description: "Browse slash commands and skills", shortcut: Some("âŒ˜/"), category: "Input", icon: "/" },
            PaletteCommand { id: "show_context", label: "Session Context", description: "View files, tools, and context usage", shortcut: Some("âŒ˜I"), category: "Session", icon: "ðŸ“š" },

            // Session & History
            PaletteCommand { id: "session_history", label: "Session History", description: "Browse and resume recent sessions", shortcut: Some("â‡§âŒ˜H"), category: "Session", icon: "ðŸ“‹" },
            PaletteCommand { id: "resume_last", label: "Resume Last Session", description: "Quickly resume the most recent session", shortcut: Some("â‡§âŒ˜R"), category: "Session", icon: "â†©" },
            PaletteCommand { id: "toggle_suggestions", label: "Toggle Suggestions", description: "Show/hide contextual suggestions", shortcut: None, category: "Session", icon: "ðŸ’¡" },

            // Claude Code Quick Commands
            PaletteCommand { id: "cmd_resume", label: "/resume", description: "Resume the last Claude Code session", shortcut: None, category: "Claude Code", icon: "â†©" },
            PaletteCommand { id: "cmd_compact", label: "/compact", description: "Compact context to free up tokens", shortcut: None, category: "Claude Code", icon: "ðŸ“¦" },
            PaletteCommand { id: "cmd_usage", label: "/usage", description: "Show token usage and costs", shortcut: None, category: "Claude Code", icon: "ðŸ“Š" },
            PaletteCommand { id: "cmd_memory", label: "/memory", description: "View and edit persistent memory", shortcut: None, category: "Claude Code", icon: "ðŸ§ " },
            PaletteCommand { id: "cmd_doctor", label: "/doctor", description: "Run diagnostics on Claude Code setup", shortcut: None, category: "Claude Code", icon: "ðŸ©º" },
            PaletteCommand { id: "cmd_permissions", label: "/permissions", description: "Manage tool permissions", shortcut: None, category: "Claude Code", icon: "ðŸ”" },
            PaletteCommand { id: "cmd_config", label: "/config", description: "View Claude Code configuration", shortcut: None, category: "Claude Code", icon: "âš™ï¸" },

            // Claude Code Skills (AI-powered workflows)
            PaletteCommand { id: "skill_apex", label: "/apex", description: "APEX workflow: Analyze-Plan-Execute-eXamine", shortcut: None, category: "Skills", icon: "âš¡" },
            PaletteCommand { id: "skill_brainstorm", label: "/brainstorm", description: "Deep iterative research with skeptical analysis", shortcut: None, category: "Skills", icon: "ðŸ’¡" },
            PaletteCommand { id: "skill_explore", label: "/explore", description: "Deep codebase exploration and analysis", shortcut: None, category: "Skills", icon: "ðŸ”" },
            PaletteCommand { id: "skill_debug", label: "/debug", description: "Systematic error debugging and resolution", shortcut: None, category: "Skills", icon: "ðŸ›" },
            PaletteCommand { id: "skill_review", label: "/review", description: "Deep PR review with parallel subagents", shortcut: None, category: "Skills", icon: "ðŸ‘€" },
            PaletteCommand { id: "skill_oneshot", label: "/oneshot", description: "Ultra-fast feature implementation", shortcut: None, category: "Skills", icon: "ðŸš€" },
            PaletteCommand { id: "skill_explain", label: "/explain", description: "Deep code explanation with visual diagrams", shortcut: None, category: "Skills", icon: "ðŸ“–" },
            PaletteCommand { id: "skill_refactor", label: "/refactor", description: "Refactor code with parallel agents", shortcut: None, category: "Skills", icon: "â™»ï¸" },
            PaletteCommand { id: "skill_docs", label: "/docs", description: "Deep documentation research", shortcut: None, category: "Skills", icon: "ðŸ“š" },
            PaletteCommand { id: "skill_ultrathink", label: "/ultrathink", description: "Deep thinking mode for elegant solutions", shortcut: None, category: "Skills", icon: "ðŸ§ " },

            // Git Skills
            PaletteCommand { id: "skill_commit", label: "/commit", description: "Quick commit with clean messages", shortcut: None, category: "Git", icon: "ðŸ“¦" },
            PaletteCommand { id: "skill_create_pr", label: "/create-pr", description: "Create and push PR with auto-generated description", shortcut: None, category: "Git", icon: "ðŸ”€" },
            PaletteCommand { id: "skill_fix_pr", label: "/fix-pr-comments", description: "Fetch and implement PR review comments", shortcut: None, category: "Git", icon: "ðŸ’¬" },
            PaletteCommand { id: "skill_merge", label: "/merge", description: "Intelligent merge with conflict resolution", shortcut: None, category: "Git", icon: "ðŸ”—" },

            // Permissions
            PaletteCommand { id: "permissions_panel", label: "Permissions Panel", description: "View and manage pending permissions", shortcut: None, category: "Security", icon: "ðŸ”" },

            // Panels
            PaletteCommand { id: "mcp_panel", label: "MCP Servers", description: "View connected MCP servers and tools", shortcut: None, category: "Panels", icon: "ðŸ”Œ" },
            PaletteCommand { id: "tasks_panel", label: "Active Tasks", description: "View running tasks and subagents", shortcut: None, category: "Panels", icon: "âš¡" },
            PaletteCommand { id: "git_panel", label: "Git Status", description: "View git repository status", shortcut: Some("âŒ˜G"), category: "Panels", icon: "ðŸ”€" },

            // Files
            PaletteCommand { id: "file_picker", label: "Insert File Mention", description: "Browse and insert @file mentions", shortcut: Some("âŒ˜P"), category: "Files", icon: "ðŸ“Ž" },

            // Bookmarks
            PaletteCommand { id: "toggle_bookmark", label: "Toggle Bookmark", description: "Bookmark/unbookmark selected message", shortcut: Some("âŒ˜D"), category: "Bookmarks", icon: "â­" },
            PaletteCommand { id: "show_bookmarks", label: "Show Bookmarks Only", description: "Filter to show only bookmarked messages", shortcut: None, category: "Bookmarks", icon: "ðŸ“Œ" },
            PaletteCommand { id: "next_bookmark", label: "Next Bookmark", description: "Jump to next bookmarked message", shortcut: Some("âŒ¥]"), category: "Bookmarks", icon: "â†’" },
            PaletteCommand { id: "prev_bookmark", label: "Previous Bookmark", description: "Jump to previous bookmarked message", shortcut: Some("âŒ¥["), category: "Bookmarks", icon: "â†" },

            // Input mode
            PaletteCommand { id: "toggle_multiline", label: "Toggle Multiline Input", description: "Switch between single and multi-line input mode", shortcut: Some("âŒ¥M"), category: "Input", icon: "â†•" },
            PaletteCommand { id: "increase_input_height", label: "Increase Input Height", description: "Make the input area taller (multiline)", shortcut: None, category: "Input", icon: "â¬†" },
            PaletteCommand { id: "decrease_input_height", label: "Decrease Input Height", description: "Make the input area shorter (multiline)", shortcut: None, category: "Input", icon: "â¬‡" },

            // Session & Metrics
            PaletteCommand { id: "session_details", label: "Session Details", description: "Show detailed session information and metrics", shortcut: Some("âŒ¥S"), category: "Session", icon: "ðŸ“Š" },
            PaletteCommand { id: "toggle_thinking", label: "Toggle Thinking Display", description: "Show/hide Claude's reasoning process", shortcut: Some("âŒ¥T"), category: "Session", icon: "ðŸ§ " },
            PaletteCommand { id: "copy_session_id", label: "Copy Session ID", description: "Copy current session ID to clipboard", shortcut: None, category: "Session", icon: "ðŸ“‹" },
            PaletteCommand { id: "cmd_clear", label: "/clear", description: "Clear the conversation context", shortcut: None, category: "Commands", icon: "ðŸ—‘" },

            // Message Actions (on selected message)
            PaletteCommand { id: "branch_selected", label: "Branch from Selected", description: "Edit and resend from selected message", shortcut: Some("âŒ¥â‡§B"), category: "Messages", icon: "ðŸ”€" },
            PaletteCommand { id: "retry_selected", label: "Retry from Selected", description: "Re-send from selected message", shortcut: Some("âŒ¥â‡§R"), category: "Messages", icon: "ðŸ”„" },
            PaletteCommand { id: "quote_selected", label: "Quote Selected", description: "Quote selected message in input", shortcut: Some("âŒ¥Q"), category: "Messages", icon: "ðŸ’¬" },
            PaletteCommand { id: "delete_selected", label: "Delete Selected", description: "Delete the selected message", shortcut: Some("âŒ¥âŒ«"), category: "Messages", icon: "ðŸ—‘" },

            // Notes & Organization
            PaletteCommand { id: "toggle_notes", label: "Session Notes", description: "Add notes to this session", shortcut: Some("âŒ¥N"), category: "Notes", icon: "ðŸ“" },
            PaletteCommand { id: "toggle_tags", label: "Conversation Tags", description: "Add tags to organize conversation", shortcut: None, category: "Notes", icon: "ðŸ·ï¸" },
            PaletteCommand { id: "toggle_favorites", label: "Favorite Prompts", description: "View and use saved prompts", shortcut: Some("âŒ¥F"), category: "Notes", icon: "â­" },
            PaletteCommand { id: "save_as_favorite", label: "Save to Favorites", description: "Save current input as favorite", shortcut: None, category: "Notes", icon: "ðŸ’¾" },
            PaletteCommand { id: "toggle_pinned", label: "Pinned Messages", description: "View all pinned messages", shortcut: Some("âŒ¥â‡§P"), category: "Notes", icon: "ðŸ“Œ" },
            PaletteCommand { id: "toggle_recent_files", label: "Recent Files", description: "View and mention recent files", shortcut: Some("âŒ¥R"), category: "Files", icon: "ðŸ“‚" },
            PaletteCommand { id: "toggle_stats", label: "Statistics", description: "View conversation statistics", shortcut: Some("âŒ˜I"), category: "Notes", icon: "ðŸ“Š" },

            // Focus & Workflow
            PaletteCommand { id: "toggle_focus_mode", label: "Focus Mode", description: "Distraction-free input mode", shortcut: Some("âŒ¥â‡§F"), category: "Workflow", icon: "ðŸŽ¯" },
            PaletteCommand { id: "quick_resume", label: "Quick Resume", description: "Resume a recent session", shortcut: Some("âŒ˜R"), category: "Workflow", icon: "â†©ï¸" },

            // Input
            PaletteCommand { id: "clear_input_history", label: "Clear Input History", description: "Clear all saved input history", shortcut: None, category: "Input", icon: "ðŸ—‘ï¸" },
            PaletteCommand { id: "toggle_input_hints", label: "Toggle Input Hints", description: "Show/hide input suggestions", shortcut: None, category: "Input", icon: "ðŸ’¡" },

            // Settings
            PaletteCommand { id: "quick_settings", label: "Quick Settings", description: "Toggle common UI settings", shortcut: Some("âŒ˜,"), category: "Settings", icon: "âš™ï¸" },

            // Help
            PaletteCommand { id: "show_shortcuts", label: "Keyboard Shortcuts", description: "Show all keyboard shortcuts", shortcut: Some("âŒ˜?"), category: "Help", icon: "âŒ¨" },

            // Summary & Title
            PaletteCommand { id: "auto_title", label: "Auto-generate Title", description: "Generate title from first message", shortcut: None, category: "Conversation", icon: "âœ¨" },
            PaletteCommand { id: "ai_title", label: "Request AI Title", description: "Ask Claude to suggest a title", shortcut: None, category: "Conversation", icon: "ðŸ¤–" },
            PaletteCommand { id: "request_summary", label: "Request Summary", description: "Ask Claude to summarize conversation", shortcut: Some("âŒ¥â‡§S"), category: "Conversation", icon: "ðŸ“" },
            PaletteCommand { id: "quick_summary", label: "Show Quick Stats", description: "Display conversation statistics", shortcut: None, category: "Conversation", icon: "ðŸ“Š" },
            PaletteCommand { id: "export_summary", label: "Export Shareable Summary", description: "Create a shareable conversation summary", shortcut: None, category: "Export", icon: "ðŸ”—" },

            // Quick File Mentions
            PaletteCommand { id: "mention_readme", label: "@README.md", description: "Mention README file", shortcut: None, category: "Files", icon: "ðŸ“–" },
            PaletteCommand { id: "mention_package", label: "@package.json", description: "Mention package.json", shortcut: None, category: "Files", icon: "ðŸ“¦" },
            PaletteCommand { id: "mention_cargo", label: "@Cargo.toml", description: "Mention Cargo.toml", shortcut: None, category: "Files", icon: "ðŸ¦€" },

            // Session Health & Performance
            PaletteCommand { id: "retry_last_request", label: "Retry Last Request", description: "Retry the last failed request", shortcut: None, category: "Actions", icon: "ðŸ”„" },
            PaletteCommand { id: "check_session_health", label: "Check Session Health", description: "View session health status", shortcut: None, category: "Session", icon: "ðŸ’š" },
            PaletteCommand { id: "clear_quick_replies", label: "Clear Quick Replies", description: "Clear suggested quick replies", shortcut: None, category: "UI", icon: "ðŸ—‘" },
            PaletteCommand { id: "dismiss_tips", label: "Dismiss All Tips", description: "Hide all onboarding tips", shortcut: None, category: "UI", icon: "ðŸ‘‹" },
        ]
    }

    /// Filter palette commands based on query
    fn filter_palette_commands(&self) -> Vec<&PaletteCommand> {
        let commands = Self::get_palette_commands();
        let query = self.palette_query.to_lowercase();

        if query.is_empty() {
            // Return a static reference would be ideal, but we need to collect
            return vec![];
        }

        // This is a workaround - in real code we'd want to store commands statically
        vec![]
    }

    /// Show a notification to the user
    pub fn show_notification(&mut self, message: impl Into<String>, notification_type: NotificationType, cx: &mut Context<Self>) {
        let notification = Notification {
            message: message.into(),
            notification_type,
            created_at: chrono::Utc::now(),
        };
        self.notifications.push(notification);
        // Auto-dismiss after 3 seconds
        cx.spawn(async move |this, cx| {
            cx.background_executor().timer(std::time::Duration::from_secs(3)).await;
            let _ = this.update(cx, |view, cx| {
                // Remove oldest notification
                if !view.notifications.is_empty() {
                    view.notifications.remove(0);
                    cx.notify();
                }
            });
        }).detach();
        cx.notify();
    }

    /// Toggle command palette
    pub fn toggle_command_palette(&mut self, cx: &mut Context<Self>) {
        self.show_command_palette = !self.show_command_palette;
        if self.show_command_palette {
            self.palette_query.clear();
            self.palette_selected_index = 0;
        }
        cx.notify();
    }

    // Palette event handlers moved to handlers.rs:
    // - handle_palette_key, palette_type_char, palette_backspace
    // - palette_select_prev, palette_select_next, palette_execute_selected

    /// Execute a command from the palette
    pub fn execute_palette_command(&mut self, command_id: &str, cx: &mut Context<Self>) {
        self.show_command_palette = false;
        self.palette_query.clear();

        match command_id {
            // Navigation
            "scroll_to_top" => self.select_first_message(cx),
            "scroll_to_bottom" => self.select_last_message(cx),
            "prev_message" => self.select_prev_message(cx),
            "next_message" => self.select_next_message(cx),
            "navigate_back" => self.navigate_back(cx),
            "navigate_forward" => self.navigate_forward(cx),
            "jump_to_search_result" => self.scroll_to_search_result(cx),

            // View
            "toggle_search" => self.toggle_search(cx),
            "toggle_stats" => self.toggle_stats(cx),
            "toggle_timestamps" => self.toggle_timestamps(cx),
            "toggle_time_separators" => self.toggle_time_separators(cx),
            "toggle_compact" => self.toggle_compact_mode(cx),
            "toggle_word_wrap" => self.toggle_word_wrap(cx),
            "toggle_line_numbers" => self.toggle_line_numbers(cx),
            "toggle_theme" => self.request_theme_toggle(cx),

            // Actions
            "copy_conversation" => self.copy_conversation_to_clipboard(cx),
            "export_conversation" => self.request_export(cx),
            "clear_conversation" => self.clear_conversation(cx),
            "copy_selected" => self.copy_selected_message(cx),
            "bookmark_selected" => self.bookmark_selected_message(cx),
            "edit_last_message" => self.edit_last_message(cx),
            "pin_selected" => {
                if let Some(idx) = self.selected_message_index {
                    self.toggle_pin(idx, cx);
                }
            }
            "copy_last_response" => self.copy_last_response(cx),

            // Message Actions (on selected)
            "branch_selected" => {
                if let Some(idx) = self.selected_message_index {
                    self.branch_from_message(idx, cx);
                } else {
                    self.show_notification("No message selected", NotificationType::Warning, cx);
                }
            }
            "retry_selected" => {
                if let Some(idx) = self.selected_message_index {
                    self.retry_from_message(idx, cx);
                } else {
                    self.show_notification("No message selected", NotificationType::Warning, cx);
                }
            }
            "quote_selected" => {
                if let Some(idx) = self.selected_message_index {
                    self.quote_message(idx, cx);
                } else {
                    self.show_notification("No message selected", NotificationType::Warning, cx);
                }
            }
            "delete_selected" => {
                if let Some(idx) = self.selected_message_index {
                    self.delete_message_at(idx, cx);
                } else {
                    self.show_notification("No message selected", NotificationType::Warning, cx);
                }
            }

            // Messages
            "expand_all" => self.expand_all(cx),
            "collapse_all" => self.collapse_all(cx),
            "collapse_tools" => self.collapse_tool_messages(cx),
            "expand_tools" => self.expand_tool_messages(cx),
            "toggle_tools" => self.toggle_collapse_tool_messages(cx),
            "collapse_assistant" => self.collapse_assistant_messages(cx),
            "expand_assistant" => self.expand_assistant_messages(cx),
            "filter_all" => self.set_message_filter(MessageFilter::All, cx),
            "filter_user" => self.set_message_filter(MessageFilter::UserOnly, cx),
            "filter_assistant" => self.set_message_filter(MessageFilter::AssistantOnly, cx),
            "filter_tools" => self.set_message_filter(MessageFilter::ToolsOnly, cx),

            // Claude CLI Commands (send as text)
            "cmd_resume" => self.send_slash_command("/resume", cx),
            "cmd_usage" => self.send_slash_command("/usage", cx),
            "cmd_help" => self.send_slash_command("/help", cx),
            "cmd_config" => self.send_slash_command("/config", cx),
            "cmd_memory" => self.send_slash_command("/memory", cx),
            "cmd_model" => self.send_slash_command("/model", cx),
            "cmd_compact" => self.send_slash_command("/compact", cx),
            "cmd_vim" => self.send_slash_command("/vim", cx),
            "cmd_doctor" => self.send_slash_command("/doctor", cx),
            "cmd_permissions" => self.send_slash_command("/permissions", cx),
            "cmd_init" => self.send_slash_command("/init", cx),
            "cmd_add_dir" => self.send_slash_command("/add-dir", cx),
            "cmd_clear" => self.send_slash_command("/clear", cx),
            "cmd_cost" => self.show_cost(cx),
            "cmd_status" => self.show_status(cx),
            "cmd_think" => self.enable_think_mode(cx),
            "cmd_think_off" => self.disable_think_mode(cx),
            "toggle_think" => self.toggle_think_mode(cx),
            "cmd_review" => self.request_code_review(cx),
            "cmd_pr" => self.create_pr(cx),
            "cmd_pr_comments" => self.show_pr_comments(cx),
            "cmd_login" => self.send_slash_command("/login", cx),
            "cmd_logout" => self.send_slash_command("/logout", cx),
            "cmd_bug" => self.send_slash_command("/bug", cx),
            "cmd_mcp" => self.send_slash_command("/mcp", cx),

            // Response Actions
            "continue_response" => self.continue_conversation(cx),
            "regenerate_response" => self.regenerate_last_response(cx),

            // Model switching
            "switch_model" => self.toggle_model_switcher(cx),

            // Templates & Commands
            "show_templates" => self.toggle_templates_panel(cx),
            "show_commands" => self.toggle_commands_panel(cx),
            "show_context" => self.toggle_context_panel(cx),

            // Session & History
            "session_history" => self.toggle_session_history(cx),
            "resume_last" => self.resume_last_session(cx),
            "toggle_suggestions" => self.toggle_suggestions(cx),

            // Permissions
            "permissions_panel" => self.toggle_permissions_panel(cx),

            // Panels
            "mcp_panel" => self.toggle_mcp_panel(cx),
            "tasks_panel" => self.toggle_tasks_panel(cx),
            "git_panel" => self.toggle_git_panel(cx),

            // Files
            "file_picker" => self.toggle_file_picker(cx),

            // Bookmarks
            "toggle_bookmark" => {
                if let Some(idx) = self.selected_message_index {
                    self.toggle_bookmark(idx, cx);
                }
            }
            "show_bookmarks" => self.toggle_bookmarked_only(cx),
            "next_bookmark" => self.jump_to_next_bookmark(cx),
            "prev_bookmark" => self.jump_to_prev_bookmark(cx),

            // Input mode
            "toggle_multiline" => self.toggle_multiline_input(cx),
            "increase_input_height" => self.increase_input_height(cx),
            "decrease_input_height" => self.decrease_input_height(cx),

            // Session & Metrics
            "session_details" => self.toggle_session_details(cx),
            "toggle_thinking" => self.toggle_thinking(cx),
            "copy_session_id" => {
                if let Some(ref info) = self.session_info {
                    cx.write_to_clipboard(gpui::ClipboardItem::new_string(info.session_id.clone()));
                    self.show_notification("Session ID copied to clipboard", NotificationType::Success, cx);
                }
            }
            "cmd_clear" => self.send_slash_command("/clear", cx),

            // Notes & Organization
            "toggle_notes" => self.toggle_notes_panel(cx),
            "toggle_tags" => self.toggle_tags_editor(cx),
            "toggle_favorites" => self.toggle_favorites_panel(cx),
            "save_as_favorite" => {
                // Prompt user would be ideal, for now save with timestamp
                let label = format!("Saved {}", chrono::Utc::now().format("%m/%d %H:%M"));
                self.save_input_as_favorite(label, cx);
            }
            "toggle_pinned" => self.toggle_pinned_panel(cx),
            "toggle_recent_files" => self.toggle_recent_files_panel(cx),
            "toggle_stats" => self.toggle_stats_panel(cx),

            // Focus & Workflow
            "toggle_focus_mode" => self.toggle_focus_mode(cx),
            "quick_resume" => self.toggle_session_history(cx),

            // Input
            "clear_input_history" => self.clear_input_history(cx),
            "toggle_input_hints" => self.toggle_input_hints(cx),

            // Settings
            "quick_settings" => self.toggle_quick_settings(cx),

            // Help
            "show_shortcuts" => self.toggle_shortcuts_help(cx),

            // Summary & Title
            "auto_title" => self.auto_generate_title(cx),
            "ai_title" => self.request_ai_title(cx),
            "request_summary" => self.request_summary(cx),
            "quick_summary" => {
                let summary = self.get_quick_summary();
                self.show_notification(summary, NotificationType::Info, cx);
            }
            "export_summary" => {
                let summary = self.export_shareable_summary();
                cx.write_to_clipboard(ClipboardItem::new_string(summary));
                self.show_notification("Summary copied to clipboard", NotificationType::Success, cx);
            }

            // Quick File Mentions
            "mention_readme" => self.quick_mention_readme(cx),
            "mention_package" => self.quick_mention_package(cx),
            "mention_cargo" => self.quick_mention_cargo(cx),

            // Session Health & Performance
            "retry_last_request" => self.retry_last_request(cx),
            "check_session_health" => {
                self.calculate_session_health(cx);
                let health = self.session_health_label();
                self.show_notification(&format!("Session health: {}", health), NotificationType::Info, cx);
            }
            "clear_quick_replies" => {
                self.quick_reply_suggestions.clear();
                self.show_notification("Quick replies cleared", NotificationType::Info, cx);
            }
            "dismiss_tips" => {
                self.show_onboarding_tips = false;
                self.show_notification("Tips dismissed", NotificationType::Info, cx);
            }

            // Claude Code Skills
            "skill_apex" => self.send_slash_command("/apex", cx),
            "skill_brainstorm" => self.send_slash_command("/brainstorm", cx),
            "skill_explore" => self.send_slash_command("/explore", cx),
            "skill_debug" => self.send_slash_command("/debug", cx),
            "skill_review" => self.send_slash_command("/review", cx),
            "skill_oneshot" => self.send_slash_command("/oneshot", cx),
            "skill_explain" => self.send_slash_command("/explain", cx),
            "skill_refactor" => self.send_slash_command("/refactor", cx),
            "skill_docs" => self.send_slash_command("/docs", cx),
            "skill_ultrathink" => self.send_slash_command("/ultrathink", cx),

            // Git Skills
            "skill_commit" => self.send_slash_command("/commit", cx),
            "skill_create_pr" => self.send_slash_command("/create-pr", cx),
            "skill_fix_pr" => self.send_slash_command("/fix-pr-comments", cx),
            "skill_merge" => self.send_slash_command("/merge", cx),

            _ => {
                tracing::warn!("Unknown palette command: {}", command_id);
            }
        }
        cx.notify();
    }

    // Keyboard shortcuts help handlers moved to handlers.rs:
    // - toggle_shortcuts_help, is_shortcuts_help_visible

    /// Get streaming dots animation text
    fn get_streaming_dots(&self) -> &'static str {
        match self.streaming_dots % 4 {
            0 => "   ",
            1 => ".  ",
            2 => ".. ",
            _ => "...",
        }
    }

    /// Get an icon for a tool name
    fn get_tool_icon(tool_name: &str) -> &'static str {
        match tool_name.to_lowercase().as_str() {
            "read" => "ðŸ“–",
            "write" => "âœï¸",
            "edit" => "âœï¸",
            "bash" => "ðŸ’»",
            "glob" => "ðŸ“",
            "grep" => "ðŸ”",
            "websearch" | "web_search" => "ðŸŒ",
            "webfetch" | "web_fetch" => "ðŸŒ",
            "task" => "ðŸ¤–",
            "notebookedit" | "notebook_edit" => "ðŸ““",
            "skill" => "âš¡",
            _ => "ðŸ”§",
        }
    }

    // set_file_drag_active moved to handlers.rs (see mouse/drag handlers)

    // Session health methods moved to session.rs:
    // - calculate_session_health
    // - get_session_health
    // - session_health_label
    // - session_health_color

    /// Get last response latency in milliseconds
    pub fn get_response_latency_ms(&self) -> Option<u64> {
        self.last_response_latency_ms
    }

    // Moved to suggestions.rs: generate_quick_reply_suggestions

    /// Dismiss an onboarding tip
    pub fn dismiss_tip(&mut self, tip_id: &'static str, cx: &mut Context<Self>) {
        self.dismissed_tips.insert(tip_id);
        cx.notify();
    }

    /// Dismiss an onboarding tip by string (for dynamically created tips)
    pub fn dismiss_tip_by_string(&mut self, tip_id: &str, cx: &mut Context<Self>) {
        // Map dynamic tip IDs to static ones
        let static_id = match tip_id {
            "tip-keyboard" => "tip-keyboard",
            "tip-commands" => "tip-commands",
            "tip-mention" => "tip-mention",
            "tip-think" => "tip-think",
            "tip-memory" => "tip-memory",
            "tip-mcp" => "tip-mcp",
            "tip-mcp-connected" => "tip-mcp-connected",
            "tip-resume" => "tip-resume",
            "tip-commit" => "tip-commit",
            "tip-review" => "tip-review",
            "tip-apex" => "tip-apex",
            _ => return, // Unknown tip, ignore
        };
        self.dismissed_tips.insert(static_id);
        cx.notify();
    }

    /// Check if a tip should be shown
    pub fn should_show_tip(&self, tip_id: &str) -> bool {
        self.show_onboarding_tips && !self.dismissed_tips.contains(tip_id)
    }

    /// Get the recommended next workflow action based on current state
    /// Returns (icon, action_name, command, description)
    pub fn get_recommended_workflow_action(&self) -> Option<(&'static str, &'static str, &'static str, &'static str)> {
        // Priority 1: Context is critical
        if self.context_usage_percentage() > 0.85 {
            return Some(("ðŸš¨", "Compact Now", "/compact", "Context is critically full - compact immediately"));
        }

        // Priority 2: Error recovery
        if self.last_error.is_some() {
            return Some(("ðŸ”„", "Retry", "retry", "Retry the last failed request"));
        }

        // Priority 3: Response was truncated
        if self.is_last_response_truncated() {
            return Some(("â–¶ï¸", "Continue", "continue", "Continue the truncated response"));
        }

        // Priority 4: Git workflow
        if let Some(ref git) = self.git_info {
            // Ready to commit
            if git.staged_count > 0 {
                return Some(("ðŸ“¦", "Commit", "/commit", "Commit your staged changes"));
            }
            // Changes need review
            if git.unstaged_count > 3 || git.untracked_count > 3 {
                return Some(("ðŸ‘€", "Review", "/review", "Review your changes before committing"));
            }
            // Behind remote
            if git.behind > 5 {
                return Some(("â¬‡ï¸", "Pull", "git pull", "Your branch is significantly behind remote"));
            }
            // Ahead of remote
            if git.ahead > 3 && git.staged_count == 0 && git.unstaged_count == 0 {
                return Some(("ðŸ”€", "Push/PR", "/create-pr", "Push your commits or create a PR"));
            }
        }

        // Priority 5: Context getting full
        if self.context_usage_percentage() > 0.7 {
            return Some(("ðŸ—œï¸", "Compact", "/compact", "Free up context space before it fills up"));
        }

        // Priority 6: Long conversation without summary
        if self.messages.len() > 20 {
            return Some(("ðŸ“‹", "Summarize", "/summarize", "Summarize the conversation progress"));
        }

        // No urgent action needed
        None
    }

    /// Get a random Claude Code pro tip based on conversation context
    pub fn get_contextual_pro_tip(&self) -> Option<(&'static str, &'static str, &'static str)> {
        // Context-aware tips: return specific tips based on current state

        // If context is getting full, prioritize compact tip
        if self.context_usage_percentage() > 0.75 {
            return Some(("ðŸ—œï¸", "Context Getting Full", "Use /compact now to free up context space before you run out"));
        }

        // If there are git changes, suggest review/commit workflow
        if let Some(ref git) = self.git_info {
            if git.is_dirty && git.staged_count > 0 {
                return Some(("ðŸ“¦", "Ready to Commit", "Use /commit to create a smart commit message for your staged changes"));
            }
            if git.is_dirty && git.unstaged_count > 3 {
                return Some(("ðŸ‘€", "Time to Review", "Use /review to get feedback on your code changes before committing"));
            }
        }

        // If MCP servers are available but user might not know
        if let Some(ref info) = self.session_info {
            if !info.mcp_servers.is_empty() && self.messages.len() < 5 {
                return Some(("ðŸ”Œ", "MCP Connected", "MCP servers ready. Press the MCP button or âŒ˜K to explore tools"));
            }
        }

        // General pro tips: (icon, title, description)
        let tips: Vec<(&'static str, &'static str, &'static str)> = vec![
            ("ðŸ§ ", "Deep Thinking", "Use /think for complex problems requiring careful reasoning"),
            ("ðŸ“¦", "Smart Commits", "Use /commit to generate meaningful commit messages automatically"),
            ("ðŸ‘€", "Code Review", "Use /review to get feedback on your code changes"),
            ("ðŸ’¾", "Persistent Memory", "Use /memory to save important context between sessions"),
            ("ðŸ”Œ", "MCP Servers", "Connect external tools via MCP for extended capabilities"),
            ("ðŸ“Š", "Token Usage", "Use /usage to see detailed token consumption"),
            ("ðŸ”", "File Search", "Type @ followed by a filename to mention and include files"),
            ("âŒ¨ï¸", "Keyboard Shortcuts", "Press âŒ˜? to see all available keyboard shortcuts"),
            ("ðŸ“œ", "Session History", "Use /resume to continue previous conversations"),
            ("ðŸ—œï¸", "Context Management", "Use /compact when context gets full to free up space"),
            ("âš¡", "Quick Commands", "Type / to access all available slash commands"),
            ("ðŸ›", "Debugging", "Use /debug to systematically analyze and fix issues"),
            ("ðŸ§ª", "Testing", "Use /test to generate comprehensive test cases"),
            ("ðŸ“", "Add Context", "Use /add-dir to include entire directories in context"),
            ("ðŸ”„", "Model Switching", "Press âŒ˜M to switch between Claude models"),
            ("ðŸš€", "Skills", "Type /skill to see available AI-powered workflows like /apex and /brainstorm"),
            ("ðŸ“‹", "Task Tracking", "Claude can track tasks automatically - just describe what needs to be done"),
            ("ðŸ”€", "Parallel Agents", "Claude can launch parallel subagents for complex multi-file tasks"),
            ("â¸ï¸", "Resume Later", "Your session is saved automatically - use /resume anytime to continue"),
            ("ðŸŽ¯", "Be Specific", "Precise prompts get better results - include file paths and exact requirements"),
        ];

        // Select tip based on conversation state
        let msg_count = self.messages.len();
        if msg_count == 0 {
            return None; // Show welcome tips instead
        }

        // Use message count as pseudo-random seed for tip selection
        let tip_index = (msg_count * 7 + 3) % tips.len();
        Some(tips[tip_index])
    }

    /// Update response latency tracking
    pub fn update_response_latency(&mut self, latency_ms: u64, cx: &mut Context<Self>) {
        self.last_response_latency_ms = Some(latency_ms);

        // Update rolling average (simple exponential moving average)
        if self.avg_response_latency_ms == 0.0 {
            self.avg_response_latency_ms = latency_ms as f64;
        } else {
            let alpha = 0.3; // Smoothing factor
            self.avg_response_latency_ms = alpha * (latency_ms as f64) + (1.0 - alpha) * self.avg_response_latency_ms;
        }

        // Recalculate session health
        self.calculate_session_health(cx);
    }

    // Streaming animation method moved to claude_events.rs:
    // - start_streaming_animation

    /// Insert a mention into the chat input
    pub fn insert_mention(&mut self, mention: &str, cx: &mut Context<Self>) {
        self.input.update(cx, |input, cx| {
            input.insert_text(mention, cx);
        });
    }

    // Slash command methods moved to context.rs:
    // - insert_slash_command

    // Scroll event handlers moved to handlers.rs:
    // - on_scroll_away, scroll_to_bottom, scroll_to_search_result
    // - toggle_auto_scroll, set_auto_scroll, is_auto_scroll

    /// Increment unread count (called when new message arrives while scrolled away)
    pub fn increment_unread(&mut self, cx: &mut Context<Self>) {
        if self.show_scroll_to_bottom {
            self.unread_count += 1;
            cx.notify();
        }
    }

    /// Get unread message count
    pub fn unread_count(&self) -> usize {
        self.unread_count
    }

    /// Toggle the stats bar visibility
    pub fn toggle_stats(&mut self, cx: &mut Context<Self>) {
        self.show_stats = !self.show_stats;
        cx.notify();
    }

    /// Show or hide stats bar
    pub fn set_show_stats(&mut self, show: bool, cx: &mut Context<Self>) {
        self.show_stats = show;
        cx.notify();
    }

    /// Toggle search panel visibility
    pub fn toggle_search(&mut self, cx: &mut Context<Self>) {
        self.show_search = !self.show_search;
        if !self.show_search {
            // Clear search when hiding
            self.search_query.clear();
            self.search_results.clear();
            self.current_search_result = 0;
        }
        cx.notify();
    }

    /// Collapse all messages
    pub fn collapse_all(&mut self, cx: &mut Context<Self>) {
        for message_view in &self.message_views {
            message_view.update(cx, |view, cx| {
                view.set_collapsed(true, cx);
            });
        }
        cx.notify();
    }

    /// Expand all messages
    pub fn expand_all(&mut self, cx: &mut Context<Self>) {
        for message_view in &self.message_views {
            message_view.update(cx, |view, cx| {
                view.set_collapsed(false, cx);
            });
        }
        cx.notify();
    }

    /// Check if all messages are collapsed
    pub fn are_all_collapsed(&self, cx: &Context<Self>) -> bool {
        if self.message_views.is_empty() {
            return false;
        }
        self.message_views.iter().all(|v| v.read(cx).is_collapsed())
    }

    /// Check if all messages are expanded
    pub fn are_all_expanded(&self, cx: &Context<Self>) -> bool {
        if self.message_views.is_empty() {
            return true;
        }
        self.message_views.iter().all(|v| !v.read(cx).is_collapsed())
    }

    /// Collapse tool messages only (tool_use and tool_result)
    pub fn collapse_tool_messages(&mut self, cx: &mut Context<Self>) {
        for (view, msg) in self.message_views.iter().zip(self.messages.iter()) {
            if matches!(msg.role, MessageRole::ToolUse | MessageRole::ToolResult) {
                view.update(cx, |v, cx| v.set_collapsed(true, cx));
            }
        }
        self.show_notification("Tool messages collapsed", NotificationType::Info, cx);
        cx.notify();
    }

    /// Expand tool messages only
    pub fn expand_tool_messages(&mut self, cx: &mut Context<Self>) {
        for (view, msg) in self.message_views.iter().zip(self.messages.iter()) {
            if matches!(msg.role, MessageRole::ToolUse | MessageRole::ToolResult) {
                view.update(cx, |v, cx| v.set_collapsed(false, cx));
            }
        }
        self.show_notification("Tool messages expanded", NotificationType::Info, cx);
        cx.notify();
    }

    /// Toggle collapse state of tool messages
    pub fn toggle_collapse_tool_messages(&mut self, cx: &mut Context<Self>) {
        // Check if any tool message is expanded
        let any_expanded = self.message_views.iter()
            .zip(self.messages.iter())
            .any(|(view, msg)| {
                matches!(msg.role, MessageRole::ToolUse | MessageRole::ToolResult) && !view.read(cx).is_collapsed()
            });

        if any_expanded {
            self.collapse_tool_messages(cx);
        } else {
            self.expand_tool_messages(cx);
        }
    }

    /// Collapse assistant messages only
    pub fn collapse_assistant_messages(&mut self, cx: &mut Context<Self>) {
        for (view, msg) in self.message_views.iter().zip(self.messages.iter()) {
            if matches!(msg.role, MessageRole::Assistant) {
                view.update(cx, |v, cx| v.set_collapsed(true, cx));
            }
        }
        self.show_notification("Assistant messages collapsed", NotificationType::Info, cx);
        cx.notify();
    }

    /// Expand assistant messages only
    pub fn expand_assistant_messages(&mut self, cx: &mut Context<Self>) {
        for (view, msg) in self.message_views.iter().zip(self.messages.iter()) {
            if matches!(msg.role, MessageRole::Assistant) {
                view.update(cx, |v, cx| v.set_collapsed(false, cx));
            }
        }
        self.show_notification("Assistant messages expanded", NotificationType::Info, cx);
        cx.notify();
    }

    /// Count of tool messages
    pub fn tool_message_count(&self) -> usize {
        self.messages.iter()
            .filter(|m| matches!(m.role, MessageRole::ToolUse | MessageRole::ToolResult))
            .count()
    }

    // Message filtering methods moved to messages.rs:
    // - message_filter, set_message_filter, next_filter
    // - filtered_message_views, filtered_message_views_with_indices
    // - visible_message_count, message_count_for_filter

    // Message group methods moved to messages.rs:
    // - time_group_label (private helper)
    // - messages_with_time_groups

    /// Toggle timestamp visibility
    pub fn toggle_timestamps(&mut self, cx: &mut Context<Self>) {
        self.show_timestamps = !self.show_timestamps;
        cx.notify();
    }

    /// Set timestamp visibility
    pub fn set_show_timestamps(&mut self, show: bool, cx: &mut Context<Self>) {
        self.show_timestamps = show;
        cx.notify();
    }

    /// Check if timestamps are visible
    pub fn timestamps_visible(&self) -> bool {
        self.show_timestamps
    }

    /// Toggle compact mode
    pub fn toggle_compact_mode(&mut self, cx: &mut Context<Self>) {
        self.compact_mode = !self.compact_mode;
        cx.notify();
    }

    /// Set compact mode
    pub fn set_compact_mode(&mut self, compact: bool, cx: &mut Context<Self>) {
        self.compact_mode = compact;
        cx.notify();
    }

    /// Check if compact mode is enabled
    pub fn is_compact_mode(&self) -> bool {
        self.compact_mode
    }

    /// Toggle time separators
    pub fn toggle_time_separators(&mut self, cx: &mut Context<Self>) {
        self.show_time_separators = !self.show_time_separators;
        cx.notify();
    }

    /// Check if time separators are enabled
    pub fn is_time_separators_enabled(&self) -> bool {
        self.show_time_separators
    }

    // Auto-scroll handler moved to handlers.rs (see scroll handlers)

    /// Toggle word wrap in code blocks
    pub fn toggle_word_wrap(&mut self, cx: &mut Context<Self>) {
        self.word_wrap = !self.word_wrap;
        cx.notify();
    }

    /// Check if word wrap is enabled
    pub fn is_word_wrap_enabled(&self) -> bool {
        self.word_wrap
    }

    /// Toggle line numbers in code blocks
    pub fn toggle_line_numbers(&mut self, cx: &mut Context<Self>) {
        self.show_line_numbers = !self.show_line_numbers;
        cx.notify();
    }

    /// Check if line numbers are shown
    pub fn is_line_numbers_enabled(&self) -> bool {
        self.show_line_numbers
    }

    /// Toggle vim mode in the input
    pub fn toggle_vim_mode(&mut self, cx: &mut Context<Self>) {
        self.input.update(cx, |input, cx| {
            input.toggle_vim_mode(cx);
        });
    }

    /// Check if vim mode is enabled
    pub fn is_vim_mode_enabled(&self, cx: &Context<ChatView>) -> bool {
        self.input.read(cx).has_vim_state()
    }

    /// Get the number of messages in the conversation
    pub fn messages_len(&self) -> usize {
        self.messages.len()
    }

    // Auto-scroll methods moved to handlers.rs (see scroll handlers)

    // Message selection methods moved to messages.rs:
    // - selected_message_index, selected_message_position
    // - select_message, select_next_message, select_prev_message
    // - update_message_selection_states

    /// Select first message
    pub fn select_first_message(&mut self, cx: &mut Context<Self>) {
        if !self.messages.is_empty() {
            self.selected_message_index = Some(0);
            self.update_message_selection_states(cx);
            cx.notify();
        }
    }

    /// Select last message
    pub fn select_last_message(&mut self, cx: &mut Context<Self>) {
        if !self.messages.is_empty() {
            self.selected_message_index = Some(self.messages.len() - 1);
            self.update_message_selection_states(cx);
            cx.notify();
        }
    }

    /// Clear message selection
    pub fn clear_message_selection(&mut self, cx: &mut Context<Self>) {
        self.selected_message_index = None;
        self.update_message_selection_states(cx);
        cx.notify();
    }

    /// Copy selected message to clipboard
    pub fn copy_selected_message(&mut self, cx: &mut Context<Self>) {
        if let Some(idx) = self.selected_message_index {
            if let Some(msg) = self.messages.get(idx) {
                let role_label = match msg.role {
                    MessageRole::User => "You",
                    MessageRole::Assistant => "Claude",
                    MessageRole::ToolUse => "Tool Use",
                    MessageRole::ToolResult => "Tool Result",
                    MessageRole::Error => "Error",
                    MessageRole::Thinking => "Thinking",
                    MessageRole::System => "System",
                };
                let text = format!("**{}:**\n{}", role_label, msg.content);
                cx.write_to_clipboard(ClipboardItem::new_string(text));
                self.show_notification(
                    format!("Message {} copied to clipboard", idx + 1),
                    NotificationType::Success,
                    cx
                );
                tracing::info!("Copied selected message {} to clipboard", idx + 1);
            }
        }
    }

    /// Toggle bookmark on selected message
    pub fn bookmark_selected_message(&mut self, cx: &mut Context<Self>) {
        if let Some(idx) = self.selected_message_index {
            if let Some(view) = self.message_views.get(idx) {
                view.update(cx, |v, cx| v.toggle_bookmark(cx));
                let is_bookmarked = view.read(cx).is_bookmarked();
                self.show_notification(
                    if is_bookmarked {
                        format!("Message {} bookmarked", idx + 1)
                    } else {
                        format!("Bookmark removed from message {}", idx + 1)
                    },
                    NotificationType::Info,
                    cx
                );
                tracing::info!(
                    "Message {} bookmark toggled: {}",
                    idx + 1,
                    if is_bookmarked { "added" } else { "removed" }
                );
                cx.notify();
            }
        }
    }

    /// Check if selected message is bookmarked
    pub fn is_selected_bookmarked(&self, cx: &Context<Self>) -> bool {
        self.selected_message_index
            .and_then(|idx| self.message_views.get(idx))
            .map(|view| view.read(cx).is_bookmarked())
            .unwrap_or(false)
    }

    /// Check if there is a selected message
    pub fn has_selected_message(&self) -> bool {
        self.selected_message_index.is_some()
    }


    // Conversation title methods moved to session.rs:
    // - conversation_title
    // - set_conversation_title
    // - display_title

    /// Start editing title
    pub fn start_editing_title(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        // Initialize buffer with current title or display title
        self.title_edit_buffer = self.conversation_title.clone().unwrap_or_else(|| {
            if let Some(first_user_msg) = self.messages.iter().find(|m| m.role == MessageRole::User) {
                let content = first_user_msg.content.trim();
                if content.len() > 50 {
                    content[..47].to_string()
                } else {
                    content.to_string()
                }
            } else {
                String::new()
            }
        });
        self.editing_title = true;
        self.title_focus.focus(window);
        cx.notify();
    }

    /// Cancel editing title (discard changes)
    pub fn cancel_editing_title(&mut self, cx: &mut Context<Self>) {
        self.editing_title = false;
        self.title_edit_buffer.clear();
        cx.notify();
    }

    /// Save the edited title
    pub fn save_edited_title(&mut self, cx: &mut Context<Self>) {
        let title = self.title_edit_buffer.trim().to_string();
        self.conversation_title = if title.is_empty() { None } else { Some(title) };
        self.editing_title = false;
        self.title_edit_buffer.clear();
        cx.notify();
    }

    /// Get the title edit buffer
    pub fn title_edit_buffer(&self) -> &str {
        &self.title_edit_buffer
    }

    /// Set the title edit buffer
    pub fn set_title_edit_buffer(&mut self, text: String, cx: &mut Context<Self>) {
        self.title_edit_buffer = text;
        cx.notify();
    }

    // Title edit handlers moved to handlers.rs:
    // - handle_title_key_down, handle_title_input

    /// Check if title is being edited
    pub fn is_editing_title(&self) -> bool {
        self.editing_title
    }

    /// Set search query and perform search
    pub fn set_search_query(&mut self, query: String, cx: &mut Context<Self>) {
        self.search_query = query;
        self.perform_search();
        self.current_search_result = 0;
        cx.notify();
    }

    /// Perform search across all messages with filters
    fn perform_search(&mut self) {
        self.search_results.clear();

        if self.search_query.is_empty() {
            return;
        }

        // Build regex pattern if regex mode is enabled
        let regex_pattern = if self.search_regex {
            regex::Regex::new(&self.search_query).ok()
        } else {
            None
        };

        for (msg_idx, message) in self.messages.iter().enumerate() {
            // Skip messages that don't match the role filter
            if !self.search_role_filter.includes_role(message.role) {
                continue;
            }

            for (line_num, line) in message.content.lines().enumerate() {
                if let Some(ref re) = regex_pattern {
                    // Regex search
                    for mat in re.find_iter(line) {
                        let start = mat.start();
                        let end = mat.end();

                        // Create snippet with context
                        let snippet_start = start.saturating_sub(30);
                        let snippet_end = (end + 30).min(line.len());
                        let mut snippet = line[snippet_start..snippet_end].to_string();
                        if snippet_start > 0 {
                            snippet = format!("...{}", snippet);
                        }
                        if snippet_end < line.len() {
                            snippet = format!("{}...", snippet);
                        }

                        self.search_results.push(ConversationSearchResult {
                            message_index: msg_idx,
                            line_number: line_num,
                            start,
                            end,
                            snippet,
                            role: message.role,
                        });
                    }
                } else {
                    // Plain text search (with optional case sensitivity)
                    let (search_line, search_query) = if self.search_case_sensitive {
                        (line.to_string(), self.search_query.clone())
                    } else {
                        (line.to_lowercase(), self.search_query.to_lowercase())
                    };

                    let mut search_start = 0;
                    while let Some(pos) = search_line[search_start..].find(&search_query) {
                        let start = search_start + pos;
                        let end = start + self.search_query.len();

                        // Create snippet with context
                        let snippet_start = start.saturating_sub(30);
                        let snippet_end = (end + 30).min(line.len());
                        let mut snippet = line[snippet_start..snippet_end].to_string();
                        if snippet_start > 0 {
                            snippet = format!("...{}", snippet);
                        }
                        if snippet_end < line.len() {
                            snippet = format!("{}...", snippet);
                        }

                        self.search_results.push(ConversationSearchResult {
                            message_index: msg_idx,
                            line_number: line_num,
                            start,
                            end,
                            snippet,
                            role: message.role,
                        });

                        search_start = start + 1;
                    }
                }
            }
        }
    }

    /// Navigate to next search result and scroll to it
    pub fn next_search_result(&mut self, cx: &mut Context<Self>) {
        if !self.search_results.is_empty() {
            self.current_search_result = (self.current_search_result + 1) % self.search_results.len();
            self.scroll_to_search_result(cx);
        }
    }

    /// Navigate to previous search result and scroll to it
    pub fn prev_search_result(&mut self, cx: &mut Context<Self>) {
        if !self.search_results.is_empty() {
            if self.current_search_result == 0 {
                self.current_search_result = self.search_results.len() - 1;
            } else {
                self.current_search_result -= 1;
            }
            self.scroll_to_search_result(cx);
        }
    }

    /// Get current search result
    pub fn current_result(&self) -> Option<&ConversationSearchResult> {
        self.search_results.get(self.current_search_result)
    }

    /// Get search results count
    pub fn search_result_count(&self) -> usize {
        self.search_results.len()
    }

    /// Get current search result index (1-based for display)
    pub fn current_result_index(&self) -> usize {
        if self.search_results.is_empty() {
            0
        } else {
            self.current_search_result + 1
        }
    }

    // scroll_to_search_result moved to handlers.rs (see scroll handlers)

    /// Jump to a specific search result by index
    pub fn jump_to_search_result(&mut self, index: usize, cx: &mut Context<Self>) {
        if index < self.search_results.len() {
            self.current_search_result = index;
            self.scroll_to_search_result(cx);
        }
    }

    // Message navigation methods moved to messages.rs:
    // - navigate_back, navigate_forward
    // - can_navigate_back, can_navigate_forward
    // - message_highlight_opacity

    /// Clear the highlight (called after animation completes or user scrolls)
    pub fn clear_highlight(&mut self) {
        self.highlighted_message = None;
    }

    /// Toggle case-sensitive search
    pub fn toggle_search_case_sensitive(&mut self, cx: &mut Context<Self>) {
        self.search_case_sensitive = !self.search_case_sensitive;
        self.perform_search();
        self.current_search_result = 0;
        cx.notify();
    }

    /// Toggle regex search
    pub fn toggle_search_regex(&mut self, cx: &mut Context<Self>) {
        self.search_regex = !self.search_regex;
        self.perform_search();
        self.current_search_result = 0;
        cx.notify();
    }

    /// Set search role filter
    pub fn set_search_role_filter(&mut self, filter: MessageFilter, cx: &mut Context<Self>) {
        self.search_role_filter = filter;
        self.perform_search();
        self.current_search_result = 0;
        cx.notify();
    }

    /// Cycle through search role filters
    pub fn cycle_search_role_filter(&mut self, cx: &mut Context<Self>) {
        self.search_role_filter = match self.search_role_filter {
            MessageFilter::All => MessageFilter::UserOnly,
            MessageFilter::UserOnly => MessageFilter::AssistantOnly,
            MessageFilter::AssistantOnly => MessageFilter::ToolsOnly,
            MessageFilter::ToolsOnly => MessageFilter::All,
        };
        self.perform_search();
        self.current_search_result = 0;
        cx.notify();
    }

    // Conversation save/load methods moved to session.rs:
    // - ensure_conversation
    // - save_message

    /// Create a message view entity from a ClaudeMessage
    pub(crate) fn create_message_view(&self, message: ClaudeMessage, cx: &mut Context<Self>) -> Entity<MessageView> {
        let app_state = self.app_state.clone();
        let view = cx.new(|cx| MessageView::new(message, app_state, cx));

        // Subscribe to message view events
        cx.subscribe(&view, |this, _, event: &MessageViewEvent, cx| {
            match event {
                MessageViewEvent::RerunCommand(cmd) => {
                    // Insert command as a prompt suggestion
                    let prompt = format!("Run this command: {}", cmd);
                    this.input.update(cx, |input, cx| {
                        input.clear(cx);
                        input.insert_text(&prompt, cx);
                    });
                    this.show_notification("Command ready to rerun", NotificationType::Info, cx);
                }
                MessageViewEvent::OpenFile(path) => {
                    cx.emit(ChatViewEvent::OpenFile(path.clone()));
                }
                MessageViewEvent::RegenerateResponse => {
                    this.regenerate_last_response(cx);
                }
                MessageViewEvent::RetryFromHere => {
                    this.regenerate_last_response(cx);
                }
                MessageViewEvent::Quote(content) => {
                    // Insert quoted content into input
                    let quoted = format!("> {}\n\n", content.lines().collect::<Vec<_>>().join("\n> "));
                    this.input.update(cx, |input, cx| {
                        input.insert_text(&quoted, cx);
                    });
                }
                MessageViewEvent::Edit(content) => {
                    // Replace input with message content for editing
                    this.input.update(cx, |input, cx| {
                        input.clear(cx);
                        input.insert_text(content, cx);
                    });
                }
                // Other events don't need special handling here
                _ => {}
            }
        }).detach();

        view
    }

    // Conversation load/add methods moved to session.rs:
    // - load_conversation
    // - add_message

    /// Request to stop the current streaming response
    pub fn request_stop(&mut self, cx: &mut Context<Self>) {
        if self.is_streaming {
            cx.emit(ChatViewEvent::StopRequested);
        }
    }

    /// Request to export the conversation (shows export panel)
    pub fn request_export(&mut self, cx: &mut Context<Self>) {
        if self.has_messages() {
            self.show_export_panel = true;
            cx.notify();
        } else {
            self.show_notification(
                "No messages to export".to_string(),
                NotificationType::Warning,
                cx
            );
        }
    }

    /// Request theme toggle (emits event for workspace to handle)
    pub fn request_theme_toggle(&mut self, cx: &mut Context<Self>) {
        cx.emit(ChatViewEvent::ThemeToggleRequested);
    }

    // Conversation clearing methods moved to session.rs:
    // - clear_conversation
    // - clear_messages
    // - clear

    // Claude event handling method moved to claude_events.rs:
    // - handle_claude_event - Main event dispatcher for Claude CLI streaming events

    // conversation_id method moved to session.rs

    // Export methods moved to session.rs:
    // - export_to_markdown
    // - export_to_json
    // - export_to_html
    // - export_to_plain_text
    // - export_with_format

    /// Export conversation to Markdown format - MOVED TO session.rs
    fn export_to_markdown_placeholder(&self) -> String {
        // This method has been moved to session.rs
        // TODO: Remove this placeholder after verifying all references are updated
        String::new()
    }

    /// Export conversation to JSON format - MOVED TO session.rs
    fn export_to_json_placeholder(&self) -> String {
        String::new()
    }

    /// Export conversation to HTML format - MOVED TO session.rs
    fn export_to_html_placeholder(&self) -> String {
        String::new()
    }

    /// Export conversation to plain text format - MOVED TO session.rs
    fn export_to_plain_text_placeholder(&self) -> String {
        String::new()
    }

    /// Export with current settings - MOVED TO session.rs
    fn export_with_format_placeholder(&self) -> String {
        String::new()
    }

    /// PLACEHOLDER - Metadata table for export
    fn _export_metadata_placeholder(&self) -> String {
        String::new()
    }


    /// Toggle export panel visibility
    pub fn toggle_export_panel(&mut self, cx: &mut Context<Self>) {
        self.show_export_panel = !self.show_export_panel;
        cx.notify();
    }

    /// Set export format
    pub fn set_export_format(&mut self, format: ExportFormat, cx: &mut Context<Self>) {
        self.export_format = format;
        cx.notify();
    }

    /// Toggle include metadata option
    pub fn toggle_export_metadata(&mut self, cx: &mut Context<Self>) {
        self.export_include_metadata = !self.export_include_metadata;
        cx.notify();
    }

    /// Toggle include tools option
    pub fn toggle_export_tools(&mut self, cx: &mut Context<Self>) {
        self.export_include_tools = !self.export_include_tools;
        cx.notify();
    }

    /// Toggle include thinking option
    pub fn toggle_export_thinking(&mut self, cx: &mut Context<Self>) {
        self.export_include_thinking = !self.export_include_thinking;
        cx.notify();
    }

    // Pinned message methods moved to messages.rs:
    // - toggle_pin, is_pinned, pinned_count
    // - get_pinned_indices, get_pinned_messages
    // - toggle_pinned_panel

    /// Toggle quick settings panel
    pub fn toggle_quick_settings(&mut self, cx: &mut Context<Self>) {
        self.show_quick_settings = !self.show_quick_settings;
        cx.notify();
    }

    /// Toggle statistics panel
    pub fn toggle_stats_panel(&mut self, cx: &mut Context<Self>) {
        self.show_stats_panel = !self.show_stats_panel;
        cx.notify();
    }

    // Statistics methods moved to messages.rs:
    // - get_conversation_stats, calculate_stats
    // - count_messages_by_role
    // - get_conversation_topics, get_tools_used
    // - get_brief_summary, format_token_count

    // ==================== Input History ====================

    // Input history handlers moved to handlers.rs:
    // - add_to_input_history, input_history_previous, input_history_next
    // - input_history_count, clear_input_history

    // ==================== Message Reactions ====================

    /// Add a reaction to a message
    pub fn add_reaction(&mut self, message_index: usize, emoji: &'static str, cx: &mut Context<Self>) {
        let reactions = self.message_reactions.entry(message_index).or_insert_with(Vec::new);

        // Check if already reacted with this emoji
        if reactions.iter().any(|r| r.emoji == emoji) {
            // Remove if already exists (toggle behavior)
            reactions.retain(|r| r.emoji != emoji);
            if reactions.is_empty() {
                self.message_reactions.remove(&message_index);
            }
        } else {
            reactions.push(MessageReaction::new(emoji));
        }
        cx.notify();
    }

    /// Get reactions for a message
    pub fn get_reactions(&self, message_index: usize) -> Option<&Vec<MessageReaction>> {
        self.message_reactions.get(&message_index)
    }

    /// Check if message has reactions
    pub fn has_reactions(&self, message_index: usize) -> bool {
        self.message_reactions.get(&message_index).map(|r| !r.is_empty()).unwrap_or(false)
    }

    /// Show quick reaction picker for a message
    pub fn show_quick_reactions(&mut self, message_index: usize, cx: &mut Context<Self>) {
        self.quick_action_message = Some(message_index);
        cx.notify();
    }

    /// Hide quick reaction picker
    pub fn hide_quick_reactions(&mut self, cx: &mut Context<Self>) {
        self.quick_action_message = None;
        cx.notify();
    }

    // ==================== Context Menu ====================

    /// Show context menu at position
    pub fn show_context_menu(&mut self, message_index: usize, x: f32, y: f32, cx: &mut Context<Self>) {
        self.context_menu = Some(ContextMenuState::new(message_index, x, y));
        cx.notify();
    }

    /// Hide context menu
    pub fn hide_context_menu(&mut self, cx: &mut Context<Self>) {
        self.context_menu = None;
        cx.notify();
    }

    /// Execute context menu action
    pub fn execute_context_menu_action(&mut self, action: &str, cx: &mut Context<Self>) {
        let message_index = match &self.context_menu {
            Some(menu) => menu.message_index,
            None => return,
        };

        match action {
            "copy" => {
                // Copy message to clipboard
                if let Some(msg) = self.messages.get(message_index) {
                    let role_label = match msg.role {
                        MessageRole::User => "You",
                        MessageRole::Assistant => "Claude",
                        MessageRole::ToolUse => "Tool Use",
                        MessageRole::ToolResult => "Tool Result",
                        MessageRole::Error => "Error",
                        MessageRole::Thinking => "Thinking",
                        MessageRole::System => "System",
                    };
                    let text = format!("**{}:**\n{}", role_label, msg.content);
                    cx.write_to_clipboard(ClipboardItem::new_string(text));
                    self.show_notification(
                        format!("Message copied to clipboard"),
                        NotificationType::Success,
                        cx
                    );
                }
            }
            "pin" => self.toggle_pin(message_index, cx),
            "bookmark" => self.toggle_bookmark(message_index, cx),
            "react" => self.show_quick_reactions(message_index, cx),
            "edit" => {
                // Edit user messages
                if let Some(msg) = self.messages.get(message_index) {
                    if matches!(msg.role, MessageRole::User) {
                        // Set input to message content for editing
                        let content = msg.content.clone();
                        self.input.update(cx, |input, cx| {
                            input.set_text(content, cx);
                        });
                    }
                }
            }
            "delete" => {
                // Remove message from list
                if message_index < self.messages.len() {
                    self.messages.remove(message_index);
                    if message_index < self.message_views.len() {
                        self.message_views.remove(message_index);
                    }
                    self.show_notification("Message deleted".to_string(), NotificationType::Info, cx);
                }
            }
            "regenerate" => {
                // Regenerate from this point
                if let Some(msg) = self.messages.get(message_index) {
                    if matches!(msg.role, MessageRole::User) {
                        let prompt = msg.content.clone();
                        // Truncate conversation up to this message
                        self.messages.truncate(message_index);
                        self.message_views.truncate(message_index);
                        // Re-submit
                        cx.emit(ChatViewEvent::Submit(prompt));
                    }
                }
            }
            "branch" => {
                self.branch_from_message(message_index, cx);
            }
            "retry_from_here" => {
                self.retry_from_message(message_index, cx);
            }
            "quote" => {
                self.quote_message(message_index, cx);
            }
            "copy_as_markdown" => {
                if let Some(msg) = self.messages.get(message_index) {
                    let role = match msg.role {
                        MessageRole::User => "**You:**",
                        MessageRole::Assistant => "**Claude:**",
                        MessageRole::ToolUse => "**Tool Use:**",
                        MessageRole::ToolResult => "**Tool Result:**",
                        MessageRole::Error => "**Error:**",
                        MessageRole::Thinking => "**Thinking:**",
                        MessageRole::System => "**System:**",
                    };
                    let markdown = format!("{}\n\n{}", role, msg.content);
                    cx.write_to_clipboard(ClipboardItem::new_string(markdown));
                    self.show_notification("Copied as Markdown", NotificationType::Success, cx);
                }
            }
            _ => {}
        }

        self.hide_context_menu(cx);
    }

    // ==================== Session Notes ====================

    /// Toggle notes panel
    pub fn toggle_notes_panel(&mut self, cx: &mut Context<Self>) {
        self.show_notes_panel = !self.show_notes_panel;
        cx.notify();
    }

    /// Set session notes
    pub fn set_session_notes(&mut self, notes: impl Into<String>, cx: &mut Context<Self>) {
        self.session_notes = notes.into();
        cx.notify();
    }

    /// Get session notes
    pub fn get_session_notes(&self) -> &str {
        &self.session_notes
    }

    /// Check if session has notes
    pub fn has_notes(&self) -> bool {
        !self.session_notes.trim().is_empty()
    }

    // ==================== Auto-Title & Summary ====================
    // Moved to summary.rs:
    // - auto_generate_title
    // - request_ai_title
    // - request_summary
    // - get_quick_summary
    // - export_shareable_summary
    // - extract_mentioned_files
    // - quick_mention_readme
    // - quick_mention_package
    // - quick_mention_cargo

    // ==================== Favorite Prompts ====================

    /// Toggle favorites panel
    pub fn toggle_favorites_panel(&mut self, cx: &mut Context<Self>) {
        self.show_favorites_panel = !self.show_favorites_panel;
        cx.notify();
    }

    // save_input_as_favorite moved to handlers.rs (see input handlers)

    /// Use a favorite prompt
    pub fn use_favorite(&mut self, id: &str, cx: &mut Context<Self>) {
        if let Some(favorite) = self.favorite_prompts.iter_mut().find(|f| f.id == id) {
            favorite.usage_count += 1;
            let text = favorite.text.clone();
            self.input.update(cx, |input, cx| {
                input.set_text(text, cx);
            });
            self.show_favorites_panel = false;
            cx.notify();
        }
    }

    /// Remove a favorite prompt
    pub fn remove_favorite(&mut self, id: &str, cx: &mut Context<Self>) {
        self.favorite_prompts.retain(|f| f.id != id);
        self.show_notification("Favorite removed".to_string(), NotificationType::Info, cx);
        cx.notify();
    }

    /// Get favorites sorted by usage
    pub fn favorites_by_usage(&self) -> Vec<&FavoritePrompt> {
        let mut favorites: Vec<_> = self.favorite_prompts.iter().collect();
        favorites.sort_by(|a, b| b.usage_count.cmp(&a.usage_count));
        favorites
    }

    // ==================== Focus Mode ====================

    /// Toggle focus mode (distraction-free input)
    pub fn toggle_focus_mode(&mut self, cx: &mut Context<Self>) {
        self.focus_mode = !self.focus_mode;
        if self.focus_mode {
            self.show_notification("Focus mode enabled".to_string(), NotificationType::Info, cx);
        } else {
            self.show_notification("Focus mode disabled".to_string(), NotificationType::Info, cx);
        }
        cx.notify();
    }

    /// Check if in focus mode
    pub fn is_focus_mode(&self) -> bool {
        self.focus_mode
    }

    // ==================== Conversation Tags ====================

    // Tag-related methods moved to tags.rs:
    // - toggle_tags_editor
    // - add_tag
    // - remove_tag
    // - get_tags
    // - has_tags
    // - suggest_tags

    /// Check if there are messages to export
    pub fn has_messages(&self) -> bool {
        !self.messages.is_empty()
    }

    /// Get the last assistant message content
    pub fn get_last_assistant_message(&self) -> Option<&str> {
        self.messages
            .iter()
            .rev()
            .find(|m| matches!(m.role, MessageRole::Assistant))
            .map(|m| m.content.as_str())
    }

    /// Get the last user message content
    pub fn get_last_user_message(&self) -> Option<&str> {
        self.messages
            .iter()
            .rev()
            .find(|m| matches!(m.role, MessageRole::User))
            .map(|m| m.content.as_str())
    }

    /// Edit the last user message (puts content back in input)
    pub fn edit_last_message(&mut self, cx: &mut Context<Self>) {
        if self.is_streaming {
            self.show_notification(
                "Cannot edit while streaming".to_string(),
                NotificationType::Warning,
                cx
            );
            return;
        }

        if let Some(content) = self.get_last_user_message() {
            let content = content.to_string();
            // Set the input to the last message content
            self.input.update(cx, |input, cx| {
                input.set_text(content.clone(), cx);
            });
            self.show_notification(
                "Editing last message".to_string(),
                NotificationType::Info,
                cx
            );
        } else {
            self.show_notification(
                "No message to edit".to_string(),
                NotificationType::Warning,
                cx
            );
        }
    }

    /// Copy the last assistant response to clipboard
    pub fn copy_last_response(&mut self, cx: &mut Context<Self>) {
        if let Some(content) = self.get_last_assistant_message() {
            let content = content.to_string();
            cx.write_to_clipboard(ClipboardItem::new_string(content.clone()));
            let word_count = content.split_whitespace().count();
            self.show_notification(
                format!("Last response copied ({} words)", word_count),
                NotificationType::Success,
                cx
            );
            tracing::info!("Last response copied to clipboard ({} words)", word_count);
        } else {
            self.show_notification(
                "No assistant response to copy".to_string(),
                NotificationType::Warning,
                cx
            );
        }
    }

    /// Branch conversation from a specific message index
    /// This removes all messages after the specified index and puts the message content in input for editing
    pub fn branch_from_message(&mut self, message_index: usize, cx: &mut Context<Self>) {
        if self.is_streaming {
            self.show_notification("Cannot branch while streaming", NotificationType::Warning, cx);
            return;
        }

        if message_index >= self.messages.len() {
            self.show_notification("Invalid message index", NotificationType::Error, cx);
            return;
        }

        let message = &self.messages[message_index];

        // Only allow branching from user messages
        if message.role != MessageRole::User {
            self.show_notification("Can only branch from your messages", NotificationType::Warning, cx);
            return;
        }

        let content = message.content.clone();

        // Remove messages from this point onwards
        let removed_count = self.messages.len() - message_index;
        self.messages.truncate(message_index);
        self.message_views.truncate(message_index);

        // Put content in input for editing
        self.input.update(cx, |input, cx| {
            input.set_text(content, cx);
        });

        self.show_notification(
            format!("Branching from message (removed {} messages)", removed_count),
            NotificationType::Info,
            cx
        );
        cx.notify();
    }

    // Message editing methods moved to messages.rs:
    // - edit_message_at, retry_from_message
    // - delete_message_at, quote_message

    /// Copy entire conversation to clipboard as plain text
    pub fn copy_conversation_to_clipboard(&mut self, cx: &mut Context<Self>) {
        if self.messages.is_empty() {
            return;
        }

        let mut text = String::new();

        for message in &self.messages {
            let role_label = match message.role {
                MessageRole::User => "You",
                MessageRole::Assistant => "Claude",
                MessageRole::ToolUse => "Tool",
                MessageRole::ToolResult => "Result",
                MessageRole::Error => "Error",
                MessageRole::Thinking => "Thinking",
                MessageRole::System => "System",
            };

            text.push_str(&format!("[{}]\n", role_label));

            if let Some(ref tool) = message.tool_name {
                text.push_str(&format!("({tool})\n"));
            }

            text.push_str(&message.content);
            text.push_str("\n\n");
        }

        cx.write_to_clipboard(ClipboardItem::new_string(text));
        let count = self.messages.len();
        self.show_notification(
            format!("Conversation copied ({} messages)", count),
            NotificationType::Success,
            cx
        );
        tracing::info!("Conversation copied to clipboard ({} messages)", count);
    }

    /// Copy conversation to clipboard as Markdown
    pub fn copy_conversation_as_markdown(&mut self, cx: &mut Context<Self>) {
        if self.messages.is_empty() {
            return;
        }

        let markdown = self.export_to_markdown();
        let count = self.messages.len();
        cx.write_to_clipboard(ClipboardItem::new_string(markdown));
        self.show_notification(
            format!("Conversation copied as Markdown ({} messages)", count),
            NotificationType::Success,
            cx
        );
        tracing::info!("Conversation copied as Markdown ({} messages)", count);
    }


    // Session capabilities formatting moved to claude_events.rs:
    // - format_session_capabilities


    // ==================== Render: Context Menu ====================

    // render_search_bar moved to render.rs
    // render_notifications moved to render.rs
    // render_shortcuts_help moved to render.rs
    // render_command_palette moved to render.rs
    // render_messages_toolbar moved to render.rs
}

impl Render for ChatView {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let theme_clone = {
            let theme = self.app_state.theme.read(cx);
            theme.clone()
        };
        let theme = &theme_clone;
        let is_streaming = self.is_streaming;
        // Dynamic streaming text based on current activity
        let streaming_text = if let Some(ref tool_name) = self.current_tool_name {
            format!("Using {}{}", tool_name, self.get_streaming_dots())
        } else if self.current_thinking.is_some() {
            format!("Thinking{}", self.get_streaming_dots())
        } else {
            format!("Claude is thinking{}", self.get_streaming_dots())
        };
        let show_stats = self.show_stats && !self.messages.is_empty();
        let show_search = self.show_search;
        let show_scroll_btn = self.show_scroll_to_bottom && self.messages.len() > 3;

        div()
            .size_full()
            .relative()
            .flex()
            .flex_col()
            .bg(theme.colors.background)
            // Status header (always visible)
            .child(self.render_status_header(&theme, cx))
            // Model switcher dropdown (when visible)
            .when(self.show_model_switcher, |d| {
                d.child(self.render_model_switcher(&theme, cx))
            })
            // Context progress bar (when we have usage data)
            .when(self.context_used > 0, |d| {
                d.child(self.render_context_progress_bar(&theme, cx))
            })
            // Messages toolbar (when messages exist)
            .when(!self.messages.is_empty(), |d| {
                d.child(self.render_messages_toolbar(&theme, cx))
            })
            // Search bar (when visible)
            .when(show_search, |d| {
                d.child(self.render_search_bar(&theme, cx))
            })
            // Messages area
            .child(
                div()
                    .flex_1()
                    .id("messages-scroll-container")
                    .overflow_y_scroll()
                    .px_4()
                    .py_4()
                    .gap_3()
                    .flex()
                    .flex_col()
                    // Existing messages (Entity-based, collapsible, filtered) with highlight and time separators
                    .children({
                        let show_separators = self.show_time_separators;
                        let highlighted_message = self.highlighted_message;
                        self.messages_with_time_groups(cx).into_iter().map(move |(time_group, idx, view)| {
                            // Calculate highlight opacity inline
                            let highlight_opacity = if let Some((highlighted_idx, timestamp)) = highlighted_message {
                                if highlighted_idx == idx {
                                    let elapsed = timestamp.elapsed().as_millis() as f32;
                                    let fade_duration = 2000.0;
                                    if elapsed < fade_duration {
                                        1.0 - (elapsed / fade_duration)
                                    } else {
                                        0.0
                                    }
                                } else {
                                    0.0
                                }
                            } else {
                                0.0
                            };
                            let is_highlighted = highlight_opacity > 0.0;

                            // Container for optional time separator + message
                            div()
                                .flex()
                                .flex_col()
                                .w_full()
                                // Time separator (if new group and enabled)
                                .when_some(time_group.filter(|_| show_separators), |d, group_label| {
                                    d.child(
                                    div()
                                        .w_full()
                                        .flex()
                                        .items_center()
                                        .gap_3()
                                        .py_2()
                                        .my_2()
                                        // Left line
                                        .child(
                                            div()
                                                .flex_1()
                                                .h(px(1.0))
                                                .bg(theme.colors.border.opacity(0.3))
                                        )
                                        // Group label
                                        .child(
                                            div()
                                                .px_3()
                                                .py_1()
                                                .rounded_full()
                                                .bg(theme.colors.surface)
                                                .border_1()
                                                .border_color(theme.colors.border.opacity(0.3))
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .child(group_label)
                                        )
                                        // Right line
                                        .child(
                                            div()
                                                .flex_1()
                                                .h(px(1.0))
                                                .bg(theme.colors.border.opacity(0.3))
                                        )
                                )
                            })
                            // Message wrapper with highlight
                            .child(
                                div()
                                    .id(ElementId::Name(format!("message-wrapper-{}", idx).into()))
                                    .w_full()
                                    .when(is_highlighted, |d| {
                                        d.bg(theme.colors.accent.opacity(highlight_opacity * 0.15))
                                            .rounded_lg()
                                            .border_l_4()
                                            .border_color(theme.colors.accent.opacity(highlight_opacity))
                                    })
                                    .child(view)
                            )
                        })
                    })
                    // Streaming message
                    .when_some(self.streaming_message_view.clone(), |this, view| {
                        this.child(view)
                    })
                    // Thinking indicator (when Claude is reasoning)
                    .when_some(self.current_thinking.clone(), |this, thinking| {
                        if !self.show_thinking {
                            return this;
                        }
                        // Show truncated thinking content
                        let preview = if thinking.len() > 200 {
                            format!("{}...", &thinking[..200])
                        } else {
                            thinking
                        };
                        this.child(
                            div()
                                .id("thinking-indicator")
                                .px_3()
                                .py_2()
                                .mx_2()
                                .mb_1()
                                .rounded_md()
                                .bg(theme.colors.warning.opacity(0.05))
                                .border_1()
                                .border_color(theme.colors.warning.opacity(0.2))
                                .child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_2()
                                        .mb_1()
                                        .child(
                                            div()
                                                .text_xs()
                                                .font_weight(FontWeight::SEMIBOLD)
                                                .text_color(theme.colors.warning)
                                                .child("ðŸ’­ Claude's Thinking")
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .child("(âŒ¥T to hide)")
                                        )
                                )
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(theme.colors.text_muted.opacity(0.8))
                                        .font_family("monospace")
                                        .child(preview)
                                )
                        )
                    })
                    // Streaming indicator with Stop button and progress info
                    .when(is_streaming, |this| {
                        // Calculate current response length
                        let response_chars = self.current_assistant_message
                            .as_ref()
                            .map(|m| m.len())
                            .unwrap_or(0);
                        let response_words = self.current_assistant_message
                            .as_ref()
                            .map(|m| m.split_whitespace().count())
                            .unwrap_or(0);
                        // Estimate tokens (~1.3 per word)
                        let est_tokens = ((response_words as f64) * 1.3).ceil() as usize;
                        // Calculate elapsed time
                        let elapsed_str = self.response_start_time
                            .map(|start| {
                                let elapsed = chrono::Utc::now().signed_duration_since(start);
                                if elapsed.num_seconds() < 60 {
                                    format!("{}s", elapsed.num_seconds())
                                } else {
                                    format!("{}m {}s", elapsed.num_minutes(), elapsed.num_seconds() % 60)
                                }
                            })
                            .unwrap_or_else(|| "0s".to_string());

                        this.child(
                            div()
                                .flex()
                                .items_center()
                                .justify_between()
                                .px_3()
                                .py_2()
                                .rounded_lg()
                                .bg(theme.colors.surface)
                                .border_1()
                                .border_color(theme.colors.accent.opacity(0.3))
                                .mx_2()
                                .mb_2()
                                // Left: Status and progress
                                .child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_3()
                                        // Animated pulse indicator or tool icon
                                        .when_some(self.current_tool_name.as_ref(), |d, tool_name| {
                                            d.child(
                                                div()
                                                    .text_base()
                                                    .child(Self::get_tool_icon(tool_name))
                                            )
                                        })
                                        .when(self.current_tool_name.is_none(), |d| {
                                            d.child(
                                                div()
                                                    .size(px(10.0))
                                                    .rounded_full()
                                                    .bg(theme.colors.accent)
                                            )
                                        })
                                        // Status text
                                        .child(
                                            div()
                                                .text_sm()
                                                .font_family("monospace")
                                                .text_color(theme.colors.text_muted)
                                                .child(streaming_text)
                                        )
                                        // Elapsed time
                                        .child(
                                            div()
                                                .flex()
                                                .items_center()
                                                .gap_1()
                                                .px_2()
                                                .py_px()
                                                .rounded_sm()
                                                .bg(theme.colors.warning.opacity(0.1))
                                                .text_xs()
                                                .text_color(theme.colors.warning)
                                                .child("â±")
                                                .child(elapsed_str)
                                        )
                                        // Progress stats
                                        .when(response_words > 0, |d| {
                                            d.child(
                                                div()
                                                    .flex()
                                                    .items_center()
                                                    .gap_2()
                                                    .px_2()
                                                    .py_px()
                                                    .rounded_sm()
                                                    .bg(theme.colors.info.opacity(0.1))
                                                    .text_xs()
                                                    .text_color(theme.colors.info)
                                                    .child(format!("{} words", response_words))
                                                    .child("Â·")
                                                    .child(format!("~{} tokens", est_tokens))
                                            )
                                        })
                                        // Streaming speed indicator with peak
                                        .when(self.last_streaming_speed > 0.0, |d| {
                                            let speed = self.last_streaming_speed;
                                            let peak = self.peak_streaming_speed;
                                            let speed_color = if speed > 50.0 {
                                                theme.colors.success
                                            } else if speed > 20.0 {
                                                theme.colors.info
                                            } else {
                                                theme.colors.warning
                                            };
                                            d.child(
                                                div()
                                                    .flex()
                                                    .items_center()
                                                    .gap_1()
                                                    .px_2()
                                                    .py_px()
                                                    .rounded_sm()
                                                    .bg(speed_color.opacity(0.1))
                                                    .text_xs()
                                                    .text_color(speed_color)
                                                    .child("âš¡")
                                                    .child(format!("{:.0}", speed))
                                                    .when(peak > speed * 1.2, |d| {
                                                        d.child(
                                                            div()
                                                                .text_color(theme.colors.text_muted)
                                                                .child(format!("(â†‘{:.0})", peak))
                                                        )
                                                    })
                                                    .child(
                                                        div()
                                                            .text_color(speed_color.opacity(0.7))
                                                            .child("tok/s")
                                                    )
                                            )
                                        })
                                )
                                // Right: Stop button with keyboard hint
                                .child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_2()
                                        .child(
                                            div()
                                                .id("stop-button")
                                                .flex()
                                                .items_center()
                                                .gap_1()
                                                .px_3()
                                                .py_1()
                                                .rounded_md()
                                                .bg(theme.colors.error.opacity(0.1))
                                                .border_1()
                                                .border_color(theme.colors.error.opacity(0.3))
                                                .text_xs()
                                                .text_color(theme.colors.error)
                                                .cursor_pointer()
                                                .hover(|style| {
                                                    style
                                                        .bg(theme.colors.error.opacity(0.2))
                                                        .border_color(theme.colors.error.opacity(0.5))
                                                })
                                                .on_click(cx.listener(|this, _, _window, cx| {
                                                    this.request_stop(cx);
                                                }))
                                                .child("Stop")
                                                .child(
                                                    div()
                                                        .text_color(theme.colors.error.opacity(0.6))
                                                        .font_family("monospace")
                                                        .child("âŽ‹")
                                                )
                                        )
                                )
                        )
                    })
                    // Empty state
                    .when(self.messages.is_empty() && self.current_assistant_message.is_none(), |this| {
                this.child(
                            div()
                                .flex_1()
                                .flex()
                                .items_center()
                                .justify_center()
                                .child(
                                    div()
                                        .flex()
                                        .flex_col()
                                        .items_center()
                                        .gap_4()
                                        .child(
                                            div()
                                                .text_xl()
                                                .font_weight(FontWeight::SEMIBOLD)
                                                .text_color(theme.colors.text_muted)
                                                .child("Welcome to Claude Visual"),
                                        )
                                        .child(
                                            div()
                                                .text_sm()
                                                .text_color(theme.colors.text_muted)
                                                .child("Start a conversation by typing a message below"),
                                        )
                                        // Session info if available
                                        .when_some(self.session_info.as_ref(), |d, info| {
                                            d.child(
                                                div()
                                                    .mt_2()
                                                    .px_3()
                                                    .py_1()
                                                    .rounded_md()
                                                    .bg(theme.colors.success.opacity(0.1))
                                                    .text_xs()
                                                    .text_color(theme.colors.success)
                                                    .child(format!("Connected to {} Â· {} tools available", info.model, info.tools.len()))
                                            )
                                        })
                                        // Welcome tips for new users (dismissable)
                                        .when(self.show_onboarding_tips, |d| {
                                            d.child(
                                                div()
                                                    .mt_4()
                                                    .child(self.render_welcome_tips(&theme, cx))
                                            )
                                        })
                                        // Recent Sessions section (for quick resume)
                                        .when(!self.recent_sessions.is_empty(), |d| {
                                            d.child(
                                                div()
                                                    .mt_6()
                                                    .w_full()
                                                    .max_w(px(600.0))
                                                    .child(
                                                        div()
                                                            .flex()
                                                            .items_center()
                                                            .justify_between()
                                                            .mb_3()
                                                            .child(
                                                                div()
                                                                    .text_xs()
                                                                    .text_color(theme.colors.text_muted)
                                                                    .child("Recent Sessions")
                                                            )
                                                            .child(
                                                                div()
                                                                    .id("view-all-sessions-btn")
                                                                    .px_2()
                                                                    .py_1()
                                                                    .rounded_md()
                                                                    .cursor_pointer()
                                                                    .text_xs()
                                                                    .text_color(theme.colors.accent)
                                                                    .hover(|s| s.bg(theme.colors.surface_hover))
                                                                    .on_click(cx.listener(|this, _, _window, cx| {
                                                                        this.show_session_history = true;
                                                                        cx.notify();
                                                                    }))
                                                                    .child("View All")
                                                            )
                                                    )
                                                    .child(self.render_recent_sessions_cards(&theme, cx))
                                            )
                                        })
                                        // Starter prompts - quick conversation starters
                                        .child(
                                            div()
                                                .mt_6()
                                                .w_full()
                                                .max_w(px(600.0))
                                                .child(
                                                    div()
                                                        .text_xs()
                                                        .text_color(theme.colors.text_muted)
                                                        .mb_3()
                                                        .child("Try asking...")
                                                )
                                                .child(self.render_starter_prompts(&theme, cx))
                                        )
                                        // Quick actions
                                        .child(
                                            div()
                                                .mt_6()
                                                .child(
                                                    div()
                                                        .text_xs()
                                                        .text_color(theme.colors.text_muted)
                                                        .mb_3()
                                                        .child("Commands")
                                                )
                                                .child(self.render_quick_actions(&theme, cx))
                                        )
                                        // Tips section
                                        .child(
                                            div()
                                                .mt_6()
                                                .flex()
                                                .flex_col()
                                                .gap_2()
                                                .child(
                                                    div()
                                                        .text_xs()
                                                        .text_color(theme.colors.text_muted)
                                                        .mb_1()
                                                        .child("Tips")
                                                )
                                                .child(
                                                    div()
                                                        .flex()
                                                        .flex_wrap()
                                                        .gap_3()
                                                        .justify_center()
                                                        .text_xs()
                                                        .text_color(theme.colors.text_muted)
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("/")
                                                                )
                                                                .child("Slash commands")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ˜?")
                                                                )
                                                                .child("Keyboard shortcuts")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("â‡§â†©")
                                                                )
                                                                .child("New line")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ˜K")
                                                                )
                                                                .child("Command palette")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("@")
                                                                )
                                                                .child("Mention files")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ˜B")
                                                                )
                                                                .child("Toggle sidebar")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ˜E")
                                                                )
                                                                .child("Export chat")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ˜M")
                                                                )
                                                                .child("Switch model")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .text_xs()
                                                                        .child("ðŸ“â†’")
                                                                )
                                                                .child("Drag & drop files")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ¥S")
                                                                )
                                                                .child("Session details")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ¥T")
                                                                )
                                                                .child("Show thinking")
                                                        )
                                                        .child(
                                                            div()
                                                                .flex()
                                                                .items_center()
                                                                .gap_1()
                                                                .child(
                                                                    div()
                                                                        .px_1()
                                                                        .rounded_sm()
                                                                        .bg(theme.colors.surface)
                                                                        .border_1()
                                                                        .border_color(theme.colors.border)
                                                                        .font_family("monospace")
                                                                        .child("âŒ˜T")
                                                                )
                                                                .child("Prompt templates")
                                                        )
                                                )
                                        ),
                                ),
                        )
                    }),
            )
            // Scroll to bottom button (floating)
            .when(show_scroll_btn, |d| {
                d.child(self.render_scroll_to_bottom(&theme, cx))
            })
            // Navigation history bar (when there's history to navigate)
            .when(self.can_navigate_back() || self.can_navigate_forward(), |d| {
                d.child(self.render_navigation_bar(&theme, cx))
            })
            // Floating action button (when not streaming and has messages)
            .when(!is_streaming && !self.messages.is_empty(), |d| {
                d.child(self.render_fab(&theme, cx))
            })
            // Floating navigation indicator (when message is selected)
            .when_some(self.selected_message_index, |d, idx| {
                let total = self.messages.len();
                d.child(
                    div()
                        .absolute()
                        .bottom(px(140.0))
                        .left_1_2()
                        .flex()
                        .items_center()
                        .gap_2()
                        .px_3()
                        .py_2()
                        .rounded_lg()
                        .bg(theme.colors.surface.opacity(0.95))
                        .border_1()
                        .border_color(theme.colors.accent.opacity(0.3))
                        .shadow_md()
                        // Position indicator
                        .child(
                            div()
                                .flex()
                                .items_center()
                                .gap_1()
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(theme.colors.accent)
                                        .font_weight(FontWeight::MEDIUM)
                                        .child(format!("{}/{}", idx + 1, total))
                                )
                        )
                        // Navigation hints
                        .child(
                            div()
                                .flex()
                                .items_center()
                                .gap_2()
                                .pl_2()
                                .border_l_1()
                                .border_color(theme.colors.border)
                                .child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .child(
                                            div()
                                                .px_1()
                                                .py_px()
                                                .rounded_sm()
                                                .bg(theme.colors.background)
                                                .border_1()
                                                .border_color(theme.colors.border)
                                                .text_xs()
                                                .font_family("monospace")
                                                .text_color(theme.colors.text_muted)
                                                .child("âŒ¥â†‘â†“")
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .child("navigate")
                                        )
                                )
                                .child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .child(
                                            div()
                                                .px_1()
                                                .py_px()
                                                .rounded_sm()
                                                .bg(theme.colors.background)
                                                .border_1()
                                                .border_color(theme.colors.border)
                                                .text_xs()
                                                .font_family("monospace")
                                                .text_color(theme.colors.text_muted)
                                                .child("âŽ‹")
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .child("clear")
                                        )
                                )
                        )
                )
            })
            // Stats bar (above input)
            .when(show_stats, |d| {
                d.child(self.render_stats_bar(&theme))
            })
            // Quick actions bar (between stats and input when not streaming)
            .when(!is_streaming && !self.messages.is_empty(), |d| {
                d.child(self.render_quick_actions_bar(&theme, cx))
            })
            // Error retry bar (when there's an error that can be retried)
            .when(self.last_error.is_some(), |d| {
                d.child(self.render_error_retry_bar(&theme, cx))
            })
            // Suggestions bar (above input when enabled and has suggestions)
            .when(self.show_suggestions && !self.contextual_suggestions.is_empty(), |d| {
                d.child(self.render_suggestions_bar(&theme, cx))
            })
            // Quick templates bar (when messages exist and not streaming)
            .when(!is_streaming && self.messages.is_empty(), |d| {
                d.child(self.render_quick_templates_bar(&theme, cx))
            })
            // Input toolbar (above input area)
            .child(
                div()
                    .flex()
                    .items_center()
                    .justify_between()
                    .px_4()
                    .py_1()
                    .border_t_1()
                    .border_color(theme.colors.border.opacity(0.5))
                    .bg(theme.colors.surface.opacity(0.3))
                    // Left side - input mode and file picker
                    .child(
                        div()
                            .flex()
                            .items_center()
                            .gap_2()
                            // Multiline toggle
                            .child(
                                div()
                                    .id("multiline-toggle")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(if self.multiline_input { theme.colors.accent } else { theme.colors.text_muted })
                                    .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.toggle_multiline_input(cx);
                                    }))
                                    .when(self.multiline_input, |d| d.child("â–¼").child("Multi-line"))
                                    .when(!self.multiline_input, |d| d.child("â–¶").child("Single-line"))
                            )
                            // Height controls (when multiline)
                            .when(self.multiline_input, |d| {
                                d.child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .child(
                                            div()
                                                .id("decrease-height")
                                                .w(px(20.0))
                                                .h(px(20.0))
                                                .flex()
                                                .items_center()
                                                .justify_center()
                                                .rounded_sm()
                                                .cursor_pointer()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                                .on_click(cx.listener(|this, _, _window, cx| {
                                                    this.decrease_input_height(cx);
                                                }))
                                                .child("âˆ’")
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .child(format!("{} lines", self.input_height_lines))
                                        )
                                        .child(
                                            div()
                                                .id("increase-height")
                                                .w(px(20.0))
                                                .h(px(20.0))
                                                .flex()
                                                .items_center()
                                                .justify_center()
                                                .rounded_sm()
                                                .cursor_pointer()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                                .on_click(cx.listener(|this, _, _window, cx| {
                                                    this.increase_input_height(cx);
                                                }))
                                                .child("+")
                                        )
                                )
                            })
                            // File mention button
                            .child(
                                div()
                                    .id("file-mention-btn")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(theme.colors.text_muted)
                                    .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.toggle_file_picker(cx);
                                    }))
                                    .child("@")
                                    .child("File")
                            )
                            // Think mode toggle button
                            .child(
                                div()
                                    .id("think-mode-toggle")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(if self.think_mode_enabled { theme.colors.warning } else { theme.colors.text_muted })
                                    .when(self.think_mode_enabled, |d| d.bg(theme.colors.warning.opacity(0.1)))
                                    .hover(|s| s.bg(theme.colors.surface_hover))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.toggle_think_mode(cx);
                                    }))
                                    .child("ðŸ§ ")
                                    .child(if self.think_mode_enabled { "Deep Think" } else { "Think" })
                            )
                            // MCP servers button (if connected)
                            .when_some(self.session_info.as_ref().filter(|i| !i.mcp_servers.is_empty()), |d, info| {
                                let server_count = info.mcp_servers.len();
                                d.child(
                                    div()
                                        .id("mcp-servers-btn")
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .px_2()
                                        .py(px(2.0))
                                        .rounded_md()
                                        .cursor_pointer()
                                        .text_xs()
                                        .text_color(theme.colors.info)
                                        .bg(theme.colors.info.opacity(0.1))
                                        .hover(|s| s.bg(theme.colors.info.opacity(0.2)))
                                        .on_click(cx.listener(|this, _, _window, cx| {
                                            this.toggle_mcp_panel(cx);
                                        }))
                                        .child("ðŸ”Œ")
                                        .child(format!("{} MCP", server_count))
                                )
                            })
                            // Memory quick access button
                            .child(
                                div()
                                    .id("memory-btn")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(theme.colors.text_muted)
                                    .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.send_slash_command("/memory", cx);
                                    }))
                                    .child("ðŸ§ ")
                                    .child("Memory")
                            )
                            // Add context button
                            .child(
                                div()
                                    .id("add-context-btn")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(theme.colors.text_muted)
                                    .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.send_slash_command("/add-dir", cx);
                                    }))
                                    .child("ðŸ“")
                                    .child("Context")
                            )
                            // Review button
                            .child(
                                div()
                                    .id("review-btn")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(theme.colors.text_muted)
                                    .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.send_slash_command("/review", cx);
                                    }))
                                    .child("ðŸ‘€")
                                    .child("Review")
                            )
                            // Commit button (when git changes exist)
                            .when(self.git_info.as_ref().map(|g| g.is_dirty).unwrap_or(false), |d| {
                                d.child(
                                    div()
                                        .id("commit-btn")
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .px_2()
                                        .py(px(2.0))
                                        .rounded_md()
                                        .cursor_pointer()
                                        .text_xs()
                                        .text_color(theme.colors.success)
                                        .bg(theme.colors.success.opacity(0.1))
                                        .hover(|s| s.bg(theme.colors.success.opacity(0.2)))
                                        .on_click(cx.listener(|this, _, _window, cx| {
                                            this.send_slash_command("/commit", cx);
                                        }))
                                        .child("ðŸ“¦")
                                        .child("Commit")
                                )
                            })
                            // Commands palette button
                            .child(
                                div()
                                    .id("commands-btn")
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .px_2()
                                    .py(px(2.0))
                                    .rounded_md()
                                    .cursor_pointer()
                                    .text_xs()
                                    .text_color(theme.colors.accent)
                                    .hover(|s| s.bg(theme.colors.accent.opacity(0.1)))
                                    .on_click(cx.listener(|this, _, _window, cx| {
                                        this.toggle_commands_panel(cx);
                                    }))
                                    .child("âš¡")
                                    .child("More")
                            )
                    )
                    // Center - Recommended action (when available)
                    .when_some(self.get_recommended_workflow_action(), |d, (icon, name, cmd, desc)| {
                        let command = cmd.to_string();
                        let is_urgent = cmd == "/compact" && self.context_usage_percentage() > 0.85;
                        d.child(
                            div()
                                .id("recommended-action")
                                .flex()
                                .items_center()
                                .gap_2()
                                .px_3()
                                .py(px(3.0))
                                .rounded_lg()
                                .cursor_pointer()
                                .border_1()
                                .border_color(if is_urgent { theme.colors.error.opacity(0.5) } else { theme.colors.warning.opacity(0.3) })
                                .bg(if is_urgent { theme.colors.error.opacity(0.1) } else { theme.colors.warning.opacity(0.1) })
                                .hover(|s| s.bg(if is_urgent { theme.colors.error.opacity(0.2) } else { theme.colors.warning.opacity(0.2) }))
                                .on_click(cx.listener(move |this, _, _window, cx| {
                                    if command.starts_with('/') {
                                        this.send_slash_command(&command, cx);
                                    } else if command == "retry" {
                                        this.retry_last_request(cx);
                                    } else if command == "continue" {
                                        this.continue_conversation(cx);
                                    }
                                }))
                                .child(
                                    div()
                                        .text_sm()
                                        .child(icon)
                                )
                                .child(
                                    div()
                                        .flex()
                                        .flex_col()
                                        .child(
                                            div()
                                                .text_xs()
                                                .font_weight(FontWeight::MEDIUM)
                                                .text_color(if is_urgent { theme.colors.error } else { theme.colors.warning })
                                                .child(format!("Suggested: {}", name))
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted)
                                                .child(desc)
                                        )
                                )
                        )
                    })
                    // Right side - model and session info
                    .child(
                        div()
                            .flex()
                            .items_center()
                            .gap_2()
                            // Quick model switcher button
                            .when_some(self.session_info.as_ref(), |d, info| {
                                let model_short = if info.model.len() > 15 {
                                    format!("{}...", &info.model[..15])
                                } else {
                                    info.model.clone()
                                };
                                d.child(
                                    div()
                                        .id("quick-model-btn")
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .px_2()
                                        .py(px(2.0))
                                        .rounded_md()
                                        .cursor_pointer()
                                        .bg(theme.colors.accent.opacity(0.1))
                                        .hover(|s| s.bg(theme.colors.accent.opacity(0.2)))
                                        .on_click(cx.listener(|this, _, _window, cx| {
                                            this.toggle_model_switcher(cx);
                                        }))
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.accent)
                                                .font_weight(FontWeight::MEDIUM)
                                                .child(model_short)
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.accent.opacity(0.7))
                                                .child("â–¾")
                                        )
                                )
                            })
                            // Session ID (if available)
                            .when_some(self.session_info.as_ref(), |d, info| {
                                let session_short = if info.session_id.len() > 8 {
                                    format!("{}...", &info.session_id[..8])
                                } else {
                                    info.session_id.clone()
                                };
                                d.child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted.opacity(0.5))
                                                .child("Session:")
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .font_family("monospace")
                                                .text_color(theme.colors.text_muted)
                                                .child(session_short)
                                        )
                                )
                            })
                            // Keyboard hint
                            .child(
                                div()
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .child(
                                        div()
                                            .px_1()
                                            .py_px()
                                            .rounded_sm()
                                            .bg(theme.colors.background)
                                            .border_1()
                                            .border_color(theme.colors.border.opacity(0.5))
                                            .text_xs()
                                            .font_family("monospace")
                                            .text_color(theme.colors.text_muted.opacity(0.6))
                                            .child("âŽ")
                                    )
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(theme.colors.text_muted.opacity(0.5))
                                            .child("send")
                                    )
                            )
                    )
            )
            // Context usage progress bar (compact, above input)
            .when(self.context_used > 0 || self.session_input_tokens > 0, |d| {
                let usage_pct = self.context_usage_percentage();
                let usage_color = if usage_pct < 0.5 {
                    theme.colors.success
                } else if usage_pct < 0.8 {
                    theme.colors.warning
                } else {
                    theme.colors.error
                };
                let tokens_used = self.context_used.max(self.session_input_tokens + self.session_output_tokens);
                let tokens_display = Self::format_token_count(tokens_used);
                d.child(
                    div()
                        .flex()
                        .flex_col()
                        .gap_px()
                        .px_3()
                        .py_1()
                        .bg(theme.colors.surface.opacity(0.5))
                        .border_t_1()
                        .border_color(theme.colors.border.opacity(0.3))
                        // Label row
                        .child(
                            div()
                                .flex()
                                .items_center()
                                .justify_between()
                                .child(
                                    div()
                                        .flex()
                                        .items_center()
                                        .gap_1()
                                        .child(
                                            div()
                                                .text_xs()
                                                .text_color(theme.colors.text_muted.opacity(0.7))
                                                .child("Context")
                                        )
                                        .child(
                                            div()
                                                .text_xs()
                                                .font_weight(FontWeight::MEDIUM)
                                                .text_color(usage_color)
                                                .child(format!("{}%", (usage_pct * 100.0) as u32))
                                        )
                                )
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(theme.colors.text_muted.opacity(0.6))
                                        .child(format!("{} tokens", tokens_display))
                                )
                        )
                        // Progress bar
                        .child(
                            div()
                                .h(px(3.0))
                                .w_full()
                                .rounded_full()
                                .bg(theme.colors.border.opacity(0.3))
                                .child(
                                    div()
                                        .h_full()
                                        .rounded_full()
                                        .bg(usage_color)
                                        .w(pct((usage_pct * 100.0) as f32))
                                )
                        )
                )
            })
            // Quick actions bar (continue, regenerate when applicable)
            .when(self.is_last_response_truncated() && !self.is_streaming, |d| {
                d.child(
                    div()
                        .flex()
                        .items_center()
                        .justify_center()
                        .gap_2()
                        .px_4()
                        .py_2()
                        .bg(theme.colors.surface.opacity(0.8))
                        .border_t_1()
                        .border_color(theme.colors.border)
                        .child(
                            div()
                                .text_xs()
                                .text_color(theme.colors.text_muted)
                                .child("Response may be incomplete")
                        )
                        .child(
                            div()
                                .id("continue-button")
                                .px_3()
                                .py_1()
                                .rounded_md()
                                .cursor_pointer()
                                .text_xs()
                                .font_weight(FontWeight::MEDIUM)
                                .bg(theme.colors.accent.opacity(0.1))
                                .text_color(theme.colors.accent)
                                .border_1()
                                .border_color(theme.colors.accent.opacity(0.3))
                                .hover(|s| s.bg(theme.colors.accent.opacity(0.2)))
                                .on_click(cx.listener(|this, _, _window, cx| {
                                    this.continue_conversation(cx);
                                }))
                                .child("Continue â–¶")
                        )
                        .child(
                            div()
                                .id("regenerate-button")
                                .px_3()
                                .py_1()
                                .rounded_md()
                                .cursor_pointer()
                                .text_xs()
                                .text_color(theme.colors.text_muted)
                                .hover(|s| s.bg(theme.colors.surface_hover).text_color(theme.colors.text))
                                .on_click(cx.listener(|this, _, _window, cx| {
                                    this.regenerate_last_response(cx);
                                }))
                                .child("Regenerate ðŸ”„")
                        )
                )
            })
            // Pro tip (shown occasionally, every 5 messages when not streaming and show tips enabled)
            .when(self.show_onboarding_tips && !is_streaming && self.messages.len() > 0 && self.messages.len() % 5 == 0, |d| {
                if let Some((icon, title, desc)) = self.get_contextual_pro_tip() {
                    d.child(
                        div()
                            .mx_4()
                            .mb_2()
                            .px_3()
                            .py_2()
                            .rounded_lg()
                            .bg(theme.colors.accent.opacity(0.05))
                            .border_1()
                            .border_color(theme.colors.accent.opacity(0.2))
                            .flex()
                            .items_center()
                            .gap_2()
                            .child(
                                div()
                                    .text_sm()
                                    .child(icon)
                            )
                            .child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .gap_px()
                                    .child(
                                        div()
                                            .text_xs()
                                            .font_weight(FontWeight::MEDIUM)
                                            .text_color(theme.colors.accent)
                                            .child(format!("Pro tip: {}", title))
                                    )
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(theme.colors.text_muted)
                                            .child(desc)
                                    )
                            )
                    )
                } else {
                    d
                }
            })
            // Quick reply suggestions (when available and not streaming)
            .when(!self.quick_reply_suggestions.is_empty() && !is_streaming, |d| {
                d.child(self.render_quick_reply_suggestions(&theme, cx))
            })
            // Git quick actions bar (when there are uncommitted changes)
            .child(self.render_git_quick_actions(&theme, cx))
            // Contextual keyboard hints bar
            .child(self.render_contextual_hints(&theme))
            // Context files preview bar (when files are attached)
            .when(!self.context_files.is_empty(), |d| {
                d.child(self.render_context_files_bar(&theme, cx))
            })
            // Input area
            .child(
                div()
                    .flex_shrink_0()
                    .border_t_1()
                    .border_color(theme.colors.border)
                    .child(self.input.clone()),
            )
            // Notifications (toast-style, floating top-right)
            .when(!self.notifications.is_empty(), |d| {
                d.child(self.render_notifications(&theme))
            })
            // Context menu (floating, higher z-index)
            .when(self.context_menu.is_some(), |d| {
                d.child(self.render_context_menu(&theme, cx))
            })
            // Keyboard shortcuts help panel (modal overlay)
            .when(self.show_shortcuts_help, |d| {
                d.child(self.render_shortcuts_help(&theme, cx))
            })
            // Command palette (modal overlay)
            .when(self.show_command_palette, |d| {
                d.child(self.render_command_palette(&theme, cx))
            })
            // Session history panel (modal overlay)
            .when(self.show_session_history, |d| {
                d.child(self.render_session_history_panel(&theme, cx))
            })
            // Permissions panel (modal overlay)
            .when(self.show_permissions_panel, |d| {
                d.child(self.render_permissions_panel(&theme, cx))
            })
            // MCP servers panel (modal overlay)
            .when(self.show_mcp_panel, |d| {
                d.child(self.render_mcp_panel(&theme, cx))
            })
            // Commands panel (modal overlay)
            .when(self.show_commands_panel, |d| {
                d.child(self.render_commands_panel(&theme, cx))
            })
            // Templates panel (modal overlay)
            .when(self.show_templates_panel, |d| {
                d.child(self.render_templates_panel(&theme, cx))
            })
            // Context panel (modal overlay)
            .when(self.show_context_panel, |d| {
                d.child(self.render_context_panel(&theme, cx))
            })
            // Export panel (modal overlay)
            .when(self.show_export_panel, |d| {
                d.child(self.render_export_panel(&theme, cx))
            })
            // Notes panel (modal overlay)
            .when(self.show_notes_panel, |d| {
                d.child(self.render_notes_panel(&theme, cx))
            })
            // Favorites panel (modal overlay)
            .when(self.show_favorites_panel, |d| {
                d.child(self.render_favorites_panel(&theme, cx))
            })
            // Tags editor panel (modal overlay)
            .when(self.show_tags_editor, |d| {
                d.child(self.render_tags_panel(&theme, cx))
            })
            // Pinned messages panel (modal overlay)
            .when(self.show_pinned_panel, |d| {
                d.child(self.render_pinned_panel(&theme, cx))
            })
            // Recent files panel (modal overlay)
            .when(self.show_recent_files_panel, |d| {
                d.child(self.render_recent_files_panel(&theme, cx))
            })
            // Statistics panel (modal overlay)
            .when(self.show_stats_panel, |d| {
                d.child(self.render_stats_panel(&theme, cx))
            })
            // Quick settings panel (modal overlay)
            .when(self.show_quick_settings, |d| {
                d.child(self.render_quick_settings_panel(&theme, cx))
            })
            // Active tasks panel (modal overlay)
            .when(self.show_tasks_panel, |d| {
                d.child(self.render_tasks_panel(&theme, cx))
            })
            // Git status panel (modal overlay)
            .when(self.show_git_panel, |d| {
                d.child(self.render_git_panel(&theme, cx))
            })
            // File picker (modal overlay)
            .when(self.file_picker_visible, |d| {
                d.child(self.render_file_picker(&theme, cx))
            })
            // Session details panel (modal overlay)
            .when(self.show_session_details, |d| {
                d.child(self.render_session_details(&theme, cx))
            })
            // File drop zone overlay (highest z-index, shown when dragging files)
            .when(self.file_drag_active, |d| {
                d.child(self.render_file_drop_zone(&theme))
            })
    }
}

// HTML helper functions moved to session.rs:
// - html_escape
// - convert_code_blocks_to_html

#[cfg(test)]
mod tests {
    use super::*;


    fn test_conversation_search_result() {
        let result = ConversationSearchResult {
            message_index: 0,
            line_number: 5,
            start: 10,
            end: 15,
            snippet: "...test query here...".to_string(),
            role: MessageRole::User,
        };

        assert_eq!(result.message_index, 0);
        assert_eq!(result.line_number, 5);
        assert_eq!(result.start, 10);
        assert_eq!(result.end, 15);
        assert!(result.snippet.contains("query"));
    }

    #[test]
    fn test_message_filter_labels() {
        assert_eq!(MessageFilter::All.label(), "All");
        assert_eq!(MessageFilter::UserOnly.label(), "You");
        assert_eq!(MessageFilter::AssistantOnly.label(), "Claude");
        assert_eq!(MessageFilter::ToolsOnly.label(), "Tools");
    }

    #[test]
    fn test_message_filter_includes_role() {
        // All filter includes everything
        assert!(MessageFilter::All.includes_role(MessageRole::User));
        assert!(MessageFilter::All.includes_role(MessageRole::Assistant));
        assert!(MessageFilter::All.includes_role(MessageRole::ToolUse));
        assert!(MessageFilter::All.includes_role(MessageRole::ToolResult));

        // UserOnly filter
        assert!(MessageFilter::UserOnly.includes_role(MessageRole::User));
        assert!(!MessageFilter::UserOnly.includes_role(MessageRole::Assistant));
        assert!(!MessageFilter::UserOnly.includes_role(MessageRole::ToolUse));

        // AssistantOnly filter
        assert!(!MessageFilter::AssistantOnly.includes_role(MessageRole::User));
        assert!(MessageFilter::AssistantOnly.includes_role(MessageRole::Assistant));
        assert!(!MessageFilter::AssistantOnly.includes_role(MessageRole::ToolUse));

        // ToolsOnly filter
        assert!(!MessageFilter::ToolsOnly.includes_role(MessageRole::User));
        assert!(!MessageFilter::ToolsOnly.includes_role(MessageRole::Assistant));
        assert!(MessageFilter::ToolsOnly.includes_role(MessageRole::ToolUse));
        assert!(MessageFilter::ToolsOnly.includes_role(MessageRole::ToolResult));
    }

    #[test]
    fn test_message_filter_all_options() {
        let options = MessageFilter::all_options();
        assert_eq!(options.len(), 4);
        assert_eq!(options[0], MessageFilter::All);
        assert_eq!(options[1], MessageFilter::UserOnly);
        assert_eq!(options[2], MessageFilter::AssistantOnly);
        assert_eq!(options[3], MessageFilter::ToolsOnly);
    }

    #[test]
    fn test_message_filter_default() {
        let filter = MessageFilter::default();
        assert_eq!(filter, MessageFilter::All);
    }
}
